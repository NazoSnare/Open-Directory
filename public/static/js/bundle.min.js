"use strict";

var databutton = {
  lastModified: function lastModified() {
    return databutton._lastModified;
  },
  lastModifiedDate: function lastModifiedDate() {
    return databutton._lastModifiedDate;
  },
  name: function name() {
    return databutton._name;
  },
  size: function size() {
    return databutton._size;
  },
  type: function type() {
    return databutton._type;
  },
  file: function file() {
    return databutton._file;
  },
  build: function build(o) {
    if (o.file) {
      var buttonEl = o.button.$el instanceof Element ? o.button.$el : document.querySelector(o.button.$el);
      var fileEl = o.file.$el instanceof Element ? o.file.$el : document.querySelector(o.file.$el);

      fileEl.onchange = function (e) {
        var filetype = e.target.files[0].type;

        for (var key in e.target.files[0]) {
          databutton["_" + key] = e.target.files[0][key];
        }

        var reader = new FileReader();
        reader.addEventListener('load', function (event) {
          var d = o.file.data;
          databutton._file = event.target.result;
          d.forEach(function (item, index) {
            if (typeof item === 'function') {
              d[index] = item();
            } else if (item === null) {
              d[index] = "";
            }
          });
          datapay.build({
            "data": d
          }, function (err, tx) {
            var s = tx.outputs[0]._script.toASM();

            o.button.outputs = [{
              script: s,
              amount: 0,
              currency: 'BSV'
            }];

            if (o.button && o.button.$pay && o.button.$pay.to) {
              o.button.$pay.to.forEach(function (receiver) {
                o.button.outputs.push({
                  to: receiver.address,
                  amount: receiver.value / 100000000,
                  currency: 'BSV'
                });
              });
            }

            delete o.button.$el;
            delete o.button.$pay;
            moneyButton.render(buttonEl, o.button);
          });
        });
        reader.readAsArrayBuffer(e.target.files[0]);
      };
    } else if (o.data) {
      datapay.build({
        "data": o.data
      }, function (err, tx) {
        var s = tx.outputs[0]._script.toASM();

        var el = o.button.$el;
        var config = o.button;
        config.outputs = [{
          script: s,
          amount: 0,
          currency: 'BSV'
        }];

        if (o.button && o.button.$pay && o.button.$pay.to) {
          o.button.$pay.to.forEach(function (receiver) {
            config.outputs.push({
              to: receiver.address,
              amount: receiver.value,
              currency: receiver.currency
            });
          });
        }

        delete config.$el;
        delete config.$pay;
        moneyButton.render(el instanceof Element ? el : document.querySelector(el), config);
      });
    }
  }
};
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

if (!SETTINGS) {
  // always expect global settings in browser...if not throw error so we don't accidentally let users continue using the app with a broken tipchain (for example)
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) == "object") {
    throw "Error reading global settings...";
  } else {
    // in node, if no settings, set bare minimum
    var SETTINGS = {
      "api_key": "1D23Q8m3GgPFH15cwseLFZVVGSNg3ypP2z",
      "api_endpoint": "https://bitomation.com/{api_action}/{api_key}/{query}",
      "tip_addresses": [{
        "address": "1LPe8CGxypahVkoBbYyoHMUAHuPb4S2JKL",
        "name": "Open Directory",
        "type": "opendirectory"
      }]
    };
  }
}

function get_local_settings() {
  var storage = window.localStorage;
  var cached_settings = storage["settings"];

  if (cached_settings) {
    try {
      return JSON.parse(cached_settings);
    } catch (e) {}
  }

  return {};
}

function save_local_settings(local_settings) {
  if (local_settings) {
    window.localStorage["settings"] = JSON.stringify(local_settings);
    console.log("Saving local settings", local_settings);
  } else {
    delete window.localStorage["settings"];
  }
}

function use_local_settings(local_settings) {
  if (local_settings && Object.keys(local_settings).length > 0) {
    console.log("Found local settings", local_settings);

    for (var key in local_settings) {
      var val = local_settings[key];
      console.log("Local setting override", key, val);
      SETTINGS[key] = val;
    }
  }
}

var BSV_PRICE = 53.00;

if ((typeof window === "undefined" ? "undefined" : _typeof(window)) == "object") {
  use_local_settings(get_local_settings());
} else {
  module.exports = SETTINGS;
}
"use strict";

function satoshisToDollars(satoshis) {
  var bitcoin_price = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BSV_PRICE;
  var show_zero = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (satoshis > 0) {
    var val = (satoshis / 100000000.0 * bitcoin_price).toLocaleString(undefined, {
      'minimumFractionDigits': 2,
      'maximumFractionDigits': 2
    });

    if (val == "0.00" || val == "0.01") {
      val = (satoshis / 100000000.0 * bitcoin_price).toLocaleString(undefined, {
        'minimumFractionDigits': 3,
        'maximumFractionDigits': 3
      }); // ends in 0

      if (val.length == 5 && val[4] == "0") {
        val = val.slice(0, 4);
      }
    }

    return "$" + val;
  } else {
    if (show_zero) {
      return "$0.00";
    }
  }
}

function numberFormat(number) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;

  if (number > 0) {
    var val = number.toLocaleString(undefined, {
      'minimumFractionDigits': 2,
      'maximumFractionDigits': length
    });

    if (val.slice(-3) == ".00") {
      return val.slice(0, -3);
    }

    return val;
  } else {
    return "0";
  }
} // https://stackoverflow.com/a/6109105


function timeDifference(current, previous) {
  if (!current || !previous) {
    return "just now";
  }

  var msPerMinute = 60 * 1000;
  var msPerHour = msPerMinute * 60;
  var msPerDay = msPerHour * 24;
  var msPerMonth = msPerDay * 30;
  var msPerYear = msPerDay * 365;
  var elapsed = current - previous;

  if (elapsed < msPerMinute) {
    return pluralize(Math.round(elapsed / 1000), 'second', 'seconds') + ' ago';
  } else if (elapsed < msPerHour) {
    return pluralize(Math.round(elapsed / msPerMinute), 'minute', 'minutes') + ' ago';
  } else if (elapsed < msPerDay) {
    return pluralize(Math.round(elapsed / msPerHour), 'hour', 'hours') + ' ago';
  } else if (elapsed < msPerMonth) {
    return pluralize(Math.round(elapsed / msPerDay), 'day', 'days') + ' ago';
  } else if (elapsed < msPerYear) {
    return pluralize(Math.round(elapsed / msPerMonth), 'month', 'months') + ' ago';
  } else {
    return pluralize(Math.round(elapsed / msPerYear), 'year', 'years') + ' ago';
  }
}

function pluralize(val, singular, plural) {
  if (val == 1) {
    return val + " " + singular;
  }

  return val + " " + plural;
}

function isBottle() {
  return navigator.userAgent.indexOf("Bottle") !== -1;
}

function getBitLinkForBMediaTXID(txid) {
  return "bit://" + B_MEDIA_PROTOCOL + "/" + txid;
}

function getBMediaURLForTXID(url) {
  if (isBottle()) {
    return url;
  } else {
    return "https://bico.media/" + url;
  }
}

function getLink(url) {
  if (url.indexOf("http") == 0) {
    return url;
  }

  if (isBottle()) {
    return url;
  } else {
    return "https://bico.media/" + url;
  }
}
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var isNode = typeof window == "undefined";

if (isNode) {
  axios = require("axios");
  SETTINGS = require("./settings.js");
  CACHED_HOMEPAGE = [];
}

var B_MEDIA_PROTOCOL = "19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut";
var BCAT_MEDIA_PROTOCOL = "15DHFxWZJT58f9nhyGnsRBqrgwK4W6h4Up";
var SUPPORTED_TIPCHAIN_PROTOCOLS = ["bit://" + B_MEDIA_PROTOCOL + "/", "b://", "bit://" + BCAT_MEDIA_PROTOCOL + "/", "https://bico.media/", "https://www.bitpaste.app/tx/", "https://memo.sv/post/", "https://dir.sv/category/", "https://dir.sv/link/", "https://bitstagram.bitdb.network/m/raw/", "https://www.audiob.app/tx/"]; // Open Directory Bitcom Protocol

var OPENDIR_PROTOCOL = "1dirzgocAsru3SdhetQkEJraQgYTf5xQm"; // Allowed actions

var OPENDIR_ACTIONS = ["category.create", "category.update", "category.delete", "entry.create", "entry.update", "entry.delete", "vote", "undo", "fork.soft"];

function get_root_category_txid() {
  if (SETTINGS.category) {
    return SETTINGS.category;
  }

  return null;
}

function toBase64(str) {
  if (isNode) {
    return Buffer.from(str).toString('base64');
  }

  return btoa(str);
}

function get_txids_query(txids) {
  var cursor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10000;
  var query = {
    "v": 3,
    "q": {
      // querying both confirmed and unconfirmed transactions
      // mongodb doesn't have a clean way to join on both so nearly every query below is doubled, on for each db
      "db": ["u", "c"],
      "limit": limit,
      // need sort here so cursor is consistent
      "sort": {
        "txid": 1
      },
      "aggregate": [{
        "$match": {
          "tx.h": {
            "$in": txids
          }
        }
      }, // let users page results
      {
        "$skip": cursor
      }]
    },
    //
    // we can clean up the response to return exactly what we need, saving bandwidth
    // the jq filter below says take all the elements in the array and return this object
    // data is a little tricky, but it grabs all s1,s2,s3,s4 data no matter how many
    "r": {
      "f": "[.[] | {                  \
                \"height\": .blk.i?,        \
                \"time\": .blk.t?,        \
                \"address\": .in[0].e.a,    \
                \"outputs\": [.out[] | {\"address\": .e.a, \"sats\": .e.v}], \
                \"txid\": .tx.h,            \
                \"data\": .out[0] | with_entries(select(((.key | startswith(\"s\")) and (.key != \"str\"))))}]"
    }
  };
  return query;
}

function get_bitdb_query() {
  var cursor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
  var query = {
    "v": 3,
    "q": {
      "find": {
        "out.s1": OPENDIR_PROTOCOL
      },
      // querying both confirmed and unconfirmed transactions
      // mongodb doesn't have a clean way to join on both so nearly every query below is doubled, on for each db
      "db": ["u", "c"],
      "limit": limit,
      "skip": cursor,
      // need sort here so cursor is consistent
      "sort": {
        "txid": 1
      }
    },
    //
    // we can clean up the response to return exactly what we need, saving bandwidth
    // the jq filter below says take all the elements in the array and return this object
    // data is a little tricky, but it grabs all s1,s2,s3,s4 data no matter how many
    "r": {
      "f": "[.[] | {                  \
                \"height\": .blk.i?,        \
                \"time\": .blk.t?,        \
                \"address\": .in[0].e.a,    \
                \"outputs\": [.out[] | {\"address\": .e.a, \"sats\": .e.v}], \
                \"txid\": .tx.h,            \
                \"data\": .out[0] | with_entries(select(((.key | startswith(\"s\")) and (.key != \"str\"))))}]"
    }
  };
  return query;
}

function fetch_from_network() {
  var category_id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var cursor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;
  var results = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var cache = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

  if (category_id == null) {
    category_id = get_root_category_txid();
  }

  var query = get_bitdb_query(cursor, limit);
  var encoded_query = toBase64(JSON.stringify(query));
  var api_url = SETTINGS.api_endpoint.replace("{api_key}", SETTINGS.api_key).replace("{api_action}", "q");
  ;
  var url = api_url.replace("{query}", encoded_query);
  var header = {
    headers: {
      key: SETTINGS.api_key
    }
  };

  function handleResponse(resolve, reject, r) {
    if (r.errors) {
      reject("error during query " + r.errors);
      return;
    }

    var items = {};
    var rows = r.c.concat(r.u).reverse();
    /*
     for (const row of rows) {
        console.log("ROW", JSON.stringify(row, null, 4));
    }
    console.log("ROWS", rows.length);
    console.log("ROW JSON", JSON.stringify(rows, null, 4));
    throw "E";
    */

    results = results.concat(rows);
    cursor += rows.length;

    if (rows.length >= limit) {
      console.log("Seems like there's still more... polling for more");
      fetch_from_network(category_id, cursor, limit, results, cache).then(resolve)["catch"](reject);
    } else {
      resolve(results);
    }
  }

  return new Promise(function (resolve, reject) {
    if (cache) {
      resolve(CACHED_HOMEPAGE);
      return;
    }

    console.log("Making HTTP request to server " + cursor + "," + limit);

    if (isNode) {
      axios = require("axios");
      axios(url, header).then(function (r) {
        if (r.status !== 200) {
          reject("Error while retrieving response from server " + r.status);
          return;
        }

        handleResponse(resolve, reject, r.data);
      })["catch"](reject);
    } else {
      fetch(url, header).then(function (r) {
        if (r.status !== 200) {
          reject("Error while retrieving response from server " + r.status);
          return;
        }

        return r.json();
      }).then(function (r) {
        handleResponse(resolve, reject, r);
      })["catch"](reject);
    }
  });
}

function fetch_txids_from_network(txids) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 75;
  var results = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  return new Promise(function (resolve, reject) {
    var txid_chunks = chunk(txids, limit);
    var actions = txid_chunks.map(function (chunk) {
      return fetch_txids_batch_from_network(chunk);
    });
    Promise.all(actions).then(function (results) {
      var all = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = results[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var result = _step.value;
          all = all.concat(result);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      resolve(all);
    });
  });
}

function fetch_txids_batch_from_network(txids) {
  var query = get_txids_query(txids);
  var b64 = toBase64(JSON.stringify(query));
  var url = "https://genesis.bitdb.network/q/1FnauZ9aUH2Bex6JzdcV4eNX7oLSSEbxtN/" + b64;
  var header = {
    headers: {
      key: "1A4xFjNatCgAK5URARbVwoxo1E3MCMETb6"
    }
  };

  function handleResponse(resolve, reject, r) {
    if (r.errors) {
      reject("error during query " + r.errors);
      return;
    }

    var items = {};
    var rows = r.c.concat(r.u).reverse();
    resolve(rows);
  }

  return new Promise(function (resolve, reject) {
    console.log("Making genesis txid HTTP request to server");

    if (isNode) {
      axios = require("axios");
      axios(url, header).then(function (r) {
        if (r.status !== 200) {
          reject("Error while retrieving response from server " + r.status);
          return;
        }

        handleResponse(resolve, reject, r.data);
      })["catch"](reject);
    } else {
      fetch(url, header).then(function (r) {
        if (r.status !== 200) {
          reject("Error while retrieving response from server " + r.status);
          return;
        }

        return r.json();
      }).then(function (r) {
        handleResponse(resolve, reject, r);
      })["catch"](reject);
    }
  });
}

function processOpenDirectoryTransactions(results) {
  return results.map(processOpenDirectoryTransaction).filter(function (r) {
    return r;
  });
} // find all children of an object that perform an action on it


function findChildrenByActionID(obj) {
  var results = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var children = [];
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = results[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var result = _step2.value;

      if (result.action_id == obj.txid) {
        var subchildren = findChildrenByActionID(result, results);
        children = children.concat([result], subchildren);
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return children;
}
/** Given a set of results, return a set of txid's to undo ... works recursively, so you can undo an undo an undo.... */


function processUndos(results) {
  // build txids
  var txids = {};
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = results[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var result = _step3.value;
      txids[result.txid] = result;
    } // find nodes that aren't referenced by action_id, we start with those

  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  var nodes = [];
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = results[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var _result = _step4.value;

      if (!txids[_result.action_id]) {
        nodes.push(_result);
      }
    } // Build actual chain by collapsing undos...then go backwards and figure out which undos stuck around
    // loop through nodes and find their children

  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
        _iterator4["return"]();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  var unique_ids = new Set();

  for (var _i = 0, _nodes = nodes; _i < _nodes.length; _i++) {
    var node = _nodes[_i];
    var children = findChildrenByActionID(node, results); // process undo

    var undo_ids = {};

    for (var i = children.length - 1; i >= 0; i--) {
      var child = children[i];

      if (child.type !== "undo") {
        continue;
      }

      if (!undo_ids[child.txid]) {
        undo_ids[child.action_id] = child;
      }
    }

    for (var undo_id in undo_ids) {
      unique_ids.add(undo_id);
    }
  }

  return Array.from(unique_ids);
}

function processRawResults(rows) {
  var txpool = processOpenDirectoryTransactions(rows);
  return processResults(rows, txpool);
}

function processResults(rows, txpool) {
  var processing = [];
  var undo_txids = processUndos(txpool);

  function process(result) {
    return processResult(result, processing, undo_txids, rows);
  } // process them in this order because blockchain may be out of order and we need to build hierarchy in correct way
  // split out create/update/delete incase they're in the same block
  // category


  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = txpool.filter(function (r) {
      return r.type == "category" && r.action == "create";
    })[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var result = _step5.value;
      processing = process(result);
    }
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
        _iterator5["return"]();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }

  var _iteratorNormalCompletion6 = true;
  var _didIteratorError6 = false;
  var _iteratorError6 = undefined;

  try {
    for (var _iterator6 = txpool.filter(function (r) {
      return r.type == "category" && r.action == "update";
    })[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
      var _result2 = _step6.value;
      processing = process(_result2);
    }
  } catch (err) {
    _didIteratorError6 = true;
    _iteratorError6 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
        _iterator6["return"]();
      }
    } finally {
      if (_didIteratorError6) {
        throw _iteratorError6;
      }
    }
  }

  var _iteratorNormalCompletion7 = true;
  var _didIteratorError7 = false;
  var _iteratorError7 = undefined;

  try {
    for (var _iterator7 = txpool.filter(function (r) {
      return r.type == "category" && r.action == "delete";
    })[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
      var _result3 = _step7.value;
      processing = process(_result3);
    } // entry

  } catch (err) {
    _didIteratorError7 = true;
    _iteratorError7 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
        _iterator7["return"]();
      }
    } finally {
      if (_didIteratorError7) {
        throw _iteratorError7;
      }
    }
  }

  var _iteratorNormalCompletion8 = true;
  var _didIteratorError8 = false;
  var _iteratorError8 = undefined;

  try {
    for (var _iterator8 = txpool.filter(function (r) {
      return r.type == "entry" && r.action == "create";
    })[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
      var _result4 = _step8.value;
      processing = process(_result4);
    }
  } catch (err) {
    _didIteratorError8 = true;
    _iteratorError8 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
        _iterator8["return"]();
      }
    } finally {
      if (_didIteratorError8) {
        throw _iteratorError8;
      }
    }
  }

  var _iteratorNormalCompletion9 = true;
  var _didIteratorError9 = false;
  var _iteratorError9 = undefined;

  try {
    for (var _iterator9 = txpool.filter(function (r) {
      return r.type == "entry" && r.action == "update";
    })[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
      var _result5 = _step9.value;
      processing = process(_result5);
    }
  } catch (err) {
    _didIteratorError9 = true;
    _iteratorError9 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
        _iterator9["return"]();
      }
    } finally {
      if (_didIteratorError9) {
        throw _iteratorError9;
      }
    }
  }

  var _iteratorNormalCompletion10 = true;
  var _didIteratorError10 = false;
  var _iteratorError10 = undefined;

  try {
    for (var _iterator10 = txpool.filter(function (r) {
      return r.type == "entry" && r.action == "delete";
    })[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
      var _result6 = _step10.value;
      processing = process(_result6);
    } // process tipchain, which right now only includes entries and categories

  } catch (err) {
    _didIteratorError10 = true;
    _iteratorError10 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
        _iterator10["return"]();
      }
    } finally {
      if (_didIteratorError10) {
        throw _iteratorError10;
      }
    }
  }

  processing = processTipchain(processing, txpool); // vote & forks

  var _iteratorNormalCompletion11 = true;
  var _didIteratorError11 = false;
  var _iteratorError11 = undefined;

  try {
    for (var _iterator11 = txpool.filter(function (r) {
      return r.type == "vote";
    })[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
      var _result7 = _step11.value;
      processing = process(_result7);
    }
  } catch (err) {
    _didIteratorError11 = true;
    _iteratorError11 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
        _iterator11["return"]();
      }
    } finally {
      if (_didIteratorError11) {
        throw _iteratorError11;
      }
    }
  }

  var _iteratorNormalCompletion12 = true;
  var _didIteratorError12 = false;
  var _iteratorError12 = undefined;

  try {
    for (var _iterator12 = txpool.filter(function (r) {
      return r.type == "fork";
    })[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
      var _result8 = _step12.value;
      processing = process(_result8);
    } // update final counts

  } catch (err) {
    _didIteratorError12 = true;
    _iteratorError12 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
        _iterator12["return"]();
      }
    } finally {
      if (_didIteratorError12) {
        throw _iteratorError12;
      }
    }
  }

  var process_pipeline = [updateCategoryEntryCounts, updateCategoryMoneyCounts, updateHottness];

  for (var _i2 = 0, _process_pipeline = process_pipeline; _i2 < _process_pipeline.length; _i2++) {
    var fn = _process_pipeline[_i2];
    processing = fn(processing);
  }

  return processing;
}

function updateHottness(results) {
  return results.map(function (result) {
    if (result.type == "entry" || result.type == "category") {
      result.hottness = calculateHottness(result);
    }

    return result;
  });
} // Hacker News score algorithm, thanks https://medium.com/hacking-and-gonzo/how-hacker-news-ranking-algorithm-works-1d9b0cf2c08d


function calculateHottness(result) {
  var gravity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.8;
  var val = (result.satoshis + result.votes) * 1.0;
  var now = new Date().getTime() / 1000;
  var time_since = !result.time ? 0 : now - result.time;
  var hours_since = time_since / (60 * 60);
  var score = val / Math.pow(hours_since + 2, gravity);
  return score;
}

function processTipchainResult(result, processing, txpool, media) {
  var opendir_tips = JSON.parse(JSON.stringify(SETTINGS.tip_addresses)); // hacky deep copy

  var result_tip = {
    address: result.address,
    txid: result.txid,
    type: result.type
  };
  var tipchain = opendir_tips.concat(result_tip);

  if (result.category) {
    var category = findObjectByTX(result.category, processing);

    if (category) {
      processTipchainResult(category, processing, txpool, media);
      tipchain = category.tipchain.concat([result_tip]);
    }
  }

  if (result.type == "entry") {
    var tip = parseTipFromEntryMedia(result, media);

    if (tip) {
      tipchain.push(tip);
    }
  }

  result.tipchain = tipchain;
  var tipchain_addresses = tipchain.map(function (t) {
    return t.address;
  });
  var satoshis = convertOutputs(result.outputs, tipchain_addresses);
  result.satoshis = satoshis;
}

function processTipchain(processing, txpool) {
  var media = {};
  var _iteratorNormalCompletion13 = true;
  var _didIteratorError13 = false;
  var _iteratorError13 = undefined;

  try {
    for (var _iterator13 = txpool.filter(function (tx) {
      return tx.type == "other" || tx.type == "category" || tx.type == "entry";
    })[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
      var tx = _step13.value;
      media[tx.txid] = tx;
    }
  } catch (err) {
    _didIteratorError13 = true;
    _iteratorError13 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
        _iterator13["return"]();
      }
    } finally {
      if (_didIteratorError13) {
        throw _iteratorError13;
      }
    }
  }

  var _iteratorNormalCompletion14 = true;
  var _didIteratorError14 = false;
  var _iteratorError14 = undefined;

  try {
    for (var _iterator14 = processing[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
      var item = _step14.value;

      if (item.type !== "entry" && item.type !== "category") {
        continue;
      }

      processTipchainResult(item, processing, txpool, media);
    }
  } catch (err) {
    _didIteratorError14 = true;
    _iteratorError14 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
        _iterator14["return"]();
      }
    } finally {
      if (_didIteratorError14) {
        throw _iteratorError14;
      }
    }
  }

  return processing;
}

function processCategoryResult(result, existing, undo, rows) {
  if (undo.indexOf(result.txid) !== -1) {
    return existing;
  }

  if (result.action == "create") {
    var _obj = result.change;

    if (result.action_id) {
      _obj.category = result.action_id;
    }

    _obj.type = result.type;
    _obj.txid = result.txid;
    _obj.address = result.address;
    _obj.height = result.height;
    _obj.time = result.time;
    _obj.outputs = result.outputs;
    _obj.votes = 0;
    _obj.entries = 0;
    existing.push(_obj);
  } else if (result.action == "update") {
    var obj = findObjectByTX(result.action_id, existing);

    if (obj) {
      for (var key in result.change) {
        obj[key] = result.change[key];
      }
    } else {
      console.log("couldn't find category for update", obj, result);
    }
  } else if (result.action == "delete") {
    var _obj2 = findObjectByTX(result.action_id, existing);

    if (_obj2) {
      _obj2.deleted = true;
    } else {
      console.log("couldn't find object for delete", _obj2, result);
    }
  } else {
    console.log("error processing category", result);
  }

  return existing;
}

function processEntryResult(result, existing, undo, rows) {
  if (undo.indexOf(result.txid) !== -1) {
    return existing;
  }

  if (result.action == "create") {
    var _obj3 = result.change;

    if (result.action_id) {
      _obj3.category = result.action_id;
    }

    _obj3.type = result.type;
    _obj3.txid = result.txid;
    _obj3.address = result.address;
    _obj3.height = result.height;
    _obj3.time = result.time;
    _obj3.outputs = result.outputs;
    _obj3.hottness = 0;
    _obj3.votes = 0;
    existing.push(_obj3);
  } else if (result.action == "update") {
    var obj = findObjectByTX(result.action_id, existing);

    if (obj) {
      for (var key in result.change) {
        obj[key] = result.change[key];
      }
    } else {
      console.log("couldn't find category for update", obj, result, existing);
    }
  } else if (result.action == "delete") {
    var _obj4 = findObjectByTX(result.action_id, existing);

    if (_obj4) {
      _obj4.deleted = true;
    } else {
      console.log("couldn't find object for delete", _obj4, result);
    }
  } else {
    console.log("error processing entry", result);
  }

  return existing;
}

function processVoteResult(result, existing, undo, rows) {
  var obj = findObjectByTX(result.action_id, existing);

  if (obj) {
    var tipchain_addresses = obj.tipchain.map(function (o) {
      return o.address;
    });
    var satoshis = convertOutputs(result.outputs, tipchain_addresses);

    if (undo.indexOf(result.txid) == -1) {
      obj.votes += 1;
      obj.satoshis += satoshis;
    } // Hacky: Backfill the raw change logs with satoshis


    if (satoshis > 0) {
      for (var i in rows) {
        if (rows[i].txid == result.txid) {
          rows[i].satoshis = satoshis;
        }
      }
    }
  } else {
    console.log("couldn't find object for vote", obj, result);
  }

  return existing;
}

function processForkResult(result, existing, rows) {
  var tipchain_addresses = [];

  if (result.action_id) {
    var obj = findObjectByTX(result.action_id, existing);

    if (obj) {
      tipchain_addresses = obj.tipchain.map(function (o) {
        return o.address;
      });
    }
  } else {
    tipchain_addresses = SETTINGS.tip_address;
  }

  var satoshis = convertOutputs(result.outputs, tipchain_addresses);

  if (!result.satoshis) {
    result.satoshis = satoshis;
  } else {
    result.satoshis += satoshis;
  } // Hacky: Backfill the raw change logs with satoshis


  if (satoshis > 0) {
    for (var i in rows) {
      if (rows[i].txid == result.txid) {
        rows[i].satoshis = satoshis;
      }
    }
  }

  return existing;
}

function processResult(result, existing, undo, rows) {
  switch (result.type) {
    case "category":
      return processCategoryResult(result, existing, undo, rows);

    case "entry":
      return processEntryResult(result, existing, undo, rows);

    case "vote":
      return processVoteResult(result, existing, undo, rows);

    case "fork":
      return processForkResult(result, existing, rows);

    default:
      console.log("error processing result", result);
      return existing;
  }
}

function parseTXIDFromLink(link) {
  for (var _i3 = 0, _SUPPORTED_TIPCHAIN_P = SUPPORTED_TIPCHAIN_PROTOCOLS; _i3 < _SUPPORTED_TIPCHAIN_P.length; _i3++) {
    var protocol = _SUPPORTED_TIPCHAIN_P[_i3];
    var bmedia_parts = link.split(protocol);

    if (bmedia_parts.length == 2) {
      var bmedia_txid = bmedia_parts[1];

      if (bmedia_txid.length == 64) {
        return bmedia_txid;
      }
    }
  }

  return null;
}

function parseTipFromEntryMedia(item, media) {
  for (var _i4 = 0, _SUPPORTED_TIPCHAIN_P2 = SUPPORTED_TIPCHAIN_PROTOCOLS; _i4 < _SUPPORTED_TIPCHAIN_P2.length; _i4++) {
    var protocol = _SUPPORTED_TIPCHAIN_P2[_i4];
    var bmedia_parts = item.link.split(protocol);

    if (bmedia_parts.length == 2) {
      var bmedia_txid = bmedia_parts[1];

      if (bmedia_txid.length == 64) {
        var bmedia_tx = media[bmedia_txid];

        if (bmedia_tx) {
          return {
            "address": bmedia_tx.address,
            "type": "media"
          };
        } else {//console.log("unable to find associated b media for item", item.txid, "media txid", bmedia_txid);
        }
      }
    }
  }

  return null;
}

function updateCategoryMoneyCounts(items) {
  var root_categories = items.filter(function (i) {
    return i.type == "category" && !i.category;
  });
  var _iteratorNormalCompletion15 = true;
  var _didIteratorError15 = false;
  var _iteratorError15 = undefined;

  try {
    for (var _iterator15 = root_categories[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
      var category = _step15.value;
      category.satoshis = updateMoneyCountUnderObject(category, items);
      category.votes = updateVoteCountUnderObject(category, items);
    }
  } catch (err) {
    _didIteratorError15 = true;
    _iteratorError15 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
        _iterator15["return"]();
      }
    } finally {
      if (_didIteratorError15) {
        throw _iteratorError15;
      }
    }
  }

  return items;
}

function updateMoneyCountUnderObject(obj, items) {
  var amount = obj.satoshis;
  var _iteratorNormalCompletion16 = true;
  var _didIteratorError16 = false;
  var _iteratorError16 = undefined;

  try {
    for (var _iterator16 = items[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
      var item = _step16.value;

      if (obj.txid == item.txid) {
        continue;
      }

      if (!item.deleted && item.category == obj.txid) {
        if (item.type == "category") {
          item.satoshis = updateMoneyCountUnderObject(item, items);
        }

        amount += item.satoshis;
      }
    }
  } catch (err) {
    _didIteratorError16 = true;
    _iteratorError16 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion16 && _iterator16["return"] != null) {
        _iterator16["return"]();
      }
    } finally {
      if (_didIteratorError16) {
        throw _iteratorError16;
      }
    }
  }

  obj.satoshis = amount;
  return amount;
}

function updateVoteCountUnderObject(obj, items) {
  var amount = obj.votes;
  var _iteratorNormalCompletion17 = true;
  var _didIteratorError17 = false;
  var _iteratorError17 = undefined;

  try {
    for (var _iterator17 = items[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
      var item = _step17.value;

      if (obj.txid == item.txid) {
        continue;
      }

      if (!item.deleted && item.category == obj.txid) {
        if (item.type == "category") {
          item.votes = updateVoteCountUnderObject(item, items);
        }

        amount += item.votes;
      }
    }
  } catch (err) {
    _didIteratorError17 = true;
    _iteratorError17 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion17 && _iterator17["return"] != null) {
        _iterator17["return"]();
      }
    } finally {
      if (_didIteratorError17) {
        throw _iteratorError17;
      }
    }
  }

  obj.votes = amount;
  return amount;
}

function updateCategoryEntryCounts(items) {
  return items.map(function (item) {
    if (item.type == "category") {
      item.entries = countObjectsUnderObject(item, items);
    }

    return item;
  });
}

function countObjectsUnderObject(obj, items) {
  var count = 0;
  var _iteratorNormalCompletion18 = true;
  var _didIteratorError18 = false;
  var _iteratorError18 = undefined;

  try {
    for (var _iterator18 = items[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
      var item = _step18.value;

      if (!item.deleted && item.category == obj.txid) {
        count += 1;

        if (item.type == "category") {
          count += countObjectsUnderObject(item, items);
        }
      }
    }
  } catch (err) {
    _didIteratorError18 = true;
    _iteratorError18 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion18 && _iterator18["return"] != null) {
        _iterator18["return"]();
      }
    } finally {
      if (_didIteratorError18) {
        throw _iteratorError18;
      }
    }
  }

  return count;
}

function expandTipchainInformation(tipchain) {
  var tipAmount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var results = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var tips = tipchain.slice(0).reverse();
  var tipchain_addresses = tips.map(function (t) {
    return t.address;
  });
  var splits = calculateTipchainSplits(tips).reverse();
  var expanded_tipchain = [];

  for (var i = 0; i < tipchain_addresses.length; i++) {
    var tip = tips[i];
    var name = tip.name;

    if (!name && tip.txid) {
      var obj = findObjectByTX(tip.txid, results);

      if (obj) {
        name = obj.name;
      }
    }

    if (!name) {
      name = "";
    }

    var split = splits[i];
    var amount = tipAmount * split;
    expanded_tipchain.push({
      "address": tip.address,
      "type": tip.type,
      "split": split,
      "amount": amount,
      "name": name
    });
  }

  return expanded_tipchain;
}

function convertKeyValues(orig_args) {
  var args = JSON.parse(JSON.stringify(orig_args)); // copy

  var keyvalues = {}; // process key/value pairs

  var key = null,
      value = null,
      tmp = null;

  while (tmp = args.shift()) {
    if (key) {
      value = tmp;
    } else {
      key = tmp;
    }

    if (key && value) {
      keyvalues[key] = value;
      key = null;
      value = null;
    }
  }

  return keyvalues;
}

function calculateTipchainSplits(tipchain) {
  if (tipchain.length == 0) {
    return [];
  }

  var weights = [];

  for (var i = 1; i <= tipchain.length; i++) {
    weights.push(1 + Math.log(i));
  }

  var total = weights.reduce(function (a, b) {
    return a + b;
  });
  var splits = weights.map(function (w) {
    return w / total;
  });
  return splits;
}

function calculateTipPayment(tipchain, amount, currency) {
  if (!amount) {
    console.log("error while calculating tip payment, invalid amount");
    return null;
  }

  if (!currency) {
    console.log("error while calculating tip payment, invalid currency");
    return null;
  }

  var weights = calculateTipchainSplits(tipchain);

  if (weights.length != tipchain.length) {
    console.log("error while calculating tip payment, weights didn't match tipchain length");
    return null;
  }

  var tips = [];

  for (var i = 0; i < tipchain.length; i++) {
    var tip_address = _typeof(tipchain[i]) == "object" ? tipchain[i].address : tipchain[i];
    var weight = weights[i];
    var tip_amount = Math.round(weight * amount * 10000) / 10000;

    if (tip_amount > 0) {
      tips.push({
        address: tip_address,
        value: tip_amount,
        currency: currency
      });
    }
  }

  return tips;
}

function processOpenDirectoryTransaction(result) {
  var _obj5;

  if (!result.txid || !result.data || !result.address) {
    console.log("MISSING DATA", result.txid, result.address, result.data, result);
    return null;
  }

  var txid = result.txid;
  var address = result.address;
  var height = result.height ? result.height : Math.Infinity;
  var time = result.time ? result.time : 0;
  var outputs = result.outputs ? result.outputs : [];
  var args = Object.values(result.data);
  var protocol_id = args.shift();
  var opendir_action = args.shift();
  var item_type, item_action;

  if (!txid) {
    console.log("Error while processing open directory transaction: no txid", result);
    return null;
  }

  if (protocol_id !== OPENDIR_PROTOCOL) {
    return {
      txid: result.txid,
      address: result.address,
      height: height,
      time: time,
      type: "other"
    };
  }

  if (OPENDIR_ACTIONS.indexOf(opendir_action) == -1) {
    console.log("Error while processing open directory transaction: invalid action", result);
    return {
      txid: result.txid,
      address: result.address,
      height: height,
      time: time,
      type: "other"
    };
  }

  if (opendir_action == "vote" || opendir_action == "undo") {
    item_type = item_action = opendir_action;
  } else {
    var parts = opendir_action.split(".");

    if (parts.length != 2) {
      console.log("Error while processing open directory transaction: invalid action", result);
      return null;
    }

    item_type = parts[0];
    item_action = parts[1];
  }

  var obj = (_obj5 = {
    type: item_type
  }, _defineProperty(_obj5, "type", item_type), _defineProperty(_obj5, "action", item_action), _defineProperty(_obj5, "txid", txid), _defineProperty(_obj5, "address", address), _defineProperty(_obj5, "height", height), _defineProperty(_obj5, "time", time), _defineProperty(_obj5, "outputs", outputs), _obj5);

  if (item_type == "category") {
    if (item_action == "create") {
      // if odd parameters, that means we've added a category
      // this will be unstable long-term, best to check if keys are in schema
      if (args.length % 2 == 1) {
        obj.action_id = args.shift();
      }

      obj.change = convertKeyValues(args);
    } else if (item_action == "update") {
      obj.action_id = args.shift();
      obj.change = convertKeyValues(args);
    } else if (item_action == "delete") {
      obj.action_id = args.shift();
      var desc = args.shift();

      if (desc) {
        obj.description = desc;
        result.description = desc;
      }
    } else {
      console.log("unknown category action", result);
    }
  } else if (item_type == "entry") {
    if (item_action == "create") {
      obj.action_id = args.shift();
      obj.change = convertKeyValues(args);

      if (obj.change.link) {
        var bmedia_txid = parseTXIDFromLink(obj.change.link);

        if (bmedia_txid) {
          obj.bmedia_txid = bmedia_txid;
        }
      }
    } else if (item_action == "update") {
      obj.action_id = args.shift();
      obj.change = convertKeyValues(args);

      if (obj.change.link) {
        var _bmedia_txid = parseTXIDFromLink(obj.change.link);

        if (_bmedia_txid) {
          obj.bmedia_txid = _bmedia_txid;
        }
      }
    } else if (item_action == "delete") {
      obj.action_id = args.shift();

      var _desc = args.shift();

      if (_desc) {
        obj.description = _desc;
        result.description = _desc;
      }
    } else {
      console.log("unknown entry action", result);
    }
  } else if (item_type == "vote") {
    obj.action_id = args.shift();
  } else if (item_type == "fork") {
    if (args.length == 2) {
      obj.fork_url = args.shift();
    } else if (args.length == 3) {
      obj.fork_url = args.shift();
      obj.action_id = args.shift();
    } else {
      //console.log("unknown number of args", result);
      return null;
    }
  } else if (item_type == "undo") {
    if (args.length == 1) {
      obj.reference_id = args.shift();
      obj.action_id = obj.reference_id;
    } else if (args.length == 2) {
      obj.reference_id = args.shift();
      obj.action_id = args.shift();
    } else {
      obj.reference_id = args.shift();
      obj.action_id = args.shift();
      obj.description = args.shift();
    } // hacky... backfill original references so we have data in changelog


    if (obj.reference_id) {
      result.reference_id = obj.reference_id;
    }

    if (obj.action_id) {
      result.action_id = obj.action_id;
    }

    if (obj.description) {
      result.description = obj.description;
    }
  } else {
    console.log("unknown item type", result);
  }

  return obj;
}

function connect_to_bitdb_socket(category_id, callback) {
  var EventSource = require("eventsource");

  var query = get_bitdb_query();
  var encoded_query = toBase64(JSON.stringify(query));
  var api_url = SETTINGS["api_endpoint"].replace("{api_key}", SETTINGS.api_key).replace("{api_action}", "s");
  ;
  var url = api_url.replace("{query}", encoded_query);

  function reconnect() {
    console.log("connecting to bitdb socket");
    var socket = null;
    socket = new EventSource(url);

    socket.onmessage = function (e) {
      try {
        var resp = JSON.parse(e.data);

        if ((resp.type == "c" || resp.type == "u") && resp.data.length > 0) {
          var rows = [];

          for (var i = 0; i < resp.data.length; i++) {
            if (resp.data[i] && resp.data[i].data && resp.data[i].data.s1 == OPENDIR_PROTOCOL) {
              rows.push(resp.data[i]);
            }
          }

          if (rows.length > 0) {
            console.log("handled new message", rows);
            callback(rows);
          }
        }
      } catch (e) {
        console.log("error handling network socket data", e);
        throw e;
      }
    };

    socket.onerror = function (e) {
      console.log("socket error", e);

      if (socket) {
        socket.close();
        socket = null;
      }

      reconnect();
    };

    return socket;
  }

  reconnect();
}

function convertOutputs(outputs) {
  var address_space = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var satoshis = 0;
  var _iteratorNormalCompletion19 = true;
  var _didIteratorError19 = false;
  var _iteratorError19 = undefined;

  try {
    for (var _iterator19 = outputs[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
      var output = _step19.value;

      if (address_space.indexOf(output.address) !== -1) {
        satoshis += output.sats;
      }
    }
  } catch (err) {
    _didIteratorError19 = true;
    _iteratorError19 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion19 && _iterator19["return"] != null) {
        _iterator19["return"]();
      }
    } finally {
      if (_didIteratorError19) {
        throw _iteratorError19;
      }
    }
  }

  return satoshis;
}

function findObjectByTX(txid) {
  var results = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var _iteratorNormalCompletion20 = true;
  var _didIteratorError20 = false;
  var _iteratorError20 = undefined;

  try {
    for (var _iterator20 = results[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
      var result = _step20.value;

      if (result.txid == txid) {
        return result;
      }
    }
  } catch (err) {
    _didIteratorError20 = true;
    _iteratorError20 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion20 && _iterator20["return"] != null) {
        _iterator20["return"]();
      }
    } finally {
      if (_didIteratorError20) {
        throw _iteratorError20;
      }
    }
  }

  return null;
}

function findRootActionID(result) {
  var results = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (!result.action_id) {
    return null;
  }

  if (result.type == "undo" && result.action_id) {
    var parent = findObjectByTX(result.action_id, results);

    if (parent && parent.type == "undo") {
      var parent_action_id = findRootActionID(parent, results);

      if (parent_action_id) {
        return parent_action_id;
      }
    }
  }

  return result.action_id;
}

function findParentCategoryChain(parent_txid) {
  var results = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var _iteratorNormalCompletion21 = true;
  var _didIteratorError21 = false;
  var _iteratorError21 = undefined;

  try {
    for (var _iterator21 = results[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
      var result = _step21.value;

      if (result.txid == parent_txid) {
        return findParentCategoryChain(result.category, results).concat([parent_txid]);
      }
    }
  } catch (err) {
    _didIteratorError21 = true;
    _iteratorError21 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion21 && _iterator21["return"] != null) {
        _iterator21["return"]();
      }
    } finally {
      if (_didIteratorError21) {
        throw _iteratorError21;
      }
    }
  }

  return [];
}

function findChildrenOfParentCategory(parent_txid) {
  var results = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (parent_txid) {
    return results.filter(function (r) {
      return r.category == parent_txid || r.action_id == parent_txid || r.reference_id == parent_txid;
    });
  } else {
    return [];
  }
}

function addNewRowsToExistingRows(new_rows, existing_rows) {
  var rows = new Map();
  var _iteratorNormalCompletion22 = true;
  var _didIteratorError22 = false;
  var _iteratorError22 = undefined;

  try {
    for (var _iterator22 = existing_rows[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
      var row = _step22.value;
      rows.set(row.txid, row);
    }
  } catch (err) {
    _didIteratorError22 = true;
    _iteratorError22 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion22 && _iterator22["return"] != null) {
        _iterator22["return"]();
      }
    } finally {
      if (_didIteratorError22) {
        throw _iteratorError22;
      }
    }
  }

  var _iteratorNormalCompletion23 = true;
  var _didIteratorError23 = false;
  var _iteratorError23 = undefined;

  try {
    for (var _iterator23 = new_rows[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
      var _row = _step23.value;
      rows.set(_row.txid, _row);
    }
  } catch (err) {
    _didIteratorError23 = true;
    _iteratorError23 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion23 && _iterator23["return"] != null) {
        _iterator23["return"]();
      }
    } finally {
      if (_didIteratorError23) {
        throw _iteratorError23;
      }
    }
  }

  return Array.from(rows.values());
}

function buildItemSliceRepresentationFromCache(category_id) {
  var cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (!category_id) {
    return cache;
  }

  var parent_categories = findParentCategoryChain(category_id, cache);
  var items = new Map();
  var _iteratorNormalCompletion24 = true;
  var _didIteratorError24 = false;
  var _iteratorError24 = undefined;

  try {
    for (var _iterator24 = parent_categories[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
      var _txid = _step24.value;
      var parent = findObjectByTX(_txid, cache);
      items.set(_txid, parent);
    }
  } catch (err) {
    _didIteratorError24 = true;
    _iteratorError24 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion24 && _iterator24["return"] != null) {
        _iterator24["return"]();
      }
    } finally {
      if (_didIteratorError24) {
        throw _iteratorError24;
      }
    }
  }

  var txids = new Set();
  var subcategory_txids = [category_id];

  while (subcategory_txids.length > 0) {
    var txid = subcategory_txids.pop();
    txids.add(txid);
    var found_children = findChildrenOfParentCategory(txid, cache);
    var _iteratorNormalCompletion25 = true;
    var _didIteratorError25 = false;
    var _iteratorError25 = undefined;

    try {
      for (var _iterator25 = found_children[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
        var child = _step25.value;

        if (child.type == "category") {
          subcategory_txids.push(child.txid);
        }

        txids.add(child.txid);
      }
    } catch (err) {
      _didIteratorError25 = true;
      _iteratorError25 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion25 && _iterator25["return"] != null) {
          _iterator25["return"]();
        }
      } finally {
        if (_didIteratorError25) {
          throw _iteratorError25;
        }
      }
    }
  }

  var children = cache.filter(function (i) {
    if (txids.has(i.txid)) {
      return true;
    }

    if (txids.has(i.action_id)) {
      return true;
    }

    if (txids.has(i.reference_id)) {
      return true;
    }
  });
  var _iteratorNormalCompletion26 = true;
  var _didIteratorError26 = false;
  var _iteratorError26 = undefined;

  try {
    for (var _iterator26 = children[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
      var _child = _step26.value;
      items.set(_child.txid, _child);
    }
  } catch (err) {
    _didIteratorError26 = true;
    _iteratorError26 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion26 && _iterator26["return"] != null) {
        _iterator26["return"]();
      }
    } finally {
      if (_didIteratorError26) {
        throw _iteratorError26;
      }
    }
  }

  return Array.from(items.values());
}

function buildRawSliceRepresentationFromCache(category_id) {
  var changelog = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var cache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  // So hacky..trying to hang on and scale... All of this needs to be rewritten 
  if (!changelog || changelog.length == 0) {
    return [];
  }

  if (!category_id) {
    return changelog;
  }

  var filtered_changelog = [];
  var items = buildItemSliceRepresentationFromCache(category_id, cache); // Grab parents first, since we don't want their children (undos, votes) we do them separate

  while (items && items.length > 0) {
    var item = items.shift();

    if (item.txid == category_id) {
      items.push(item);
      break;
    } else {
      filtered_changelog.push(findObjectByTX(item.txid, changelog));
    }
  }

  var txids = items.map(function (i) {
    return i.txid;
  }).filter(function (i) {
    return i;
  });
  var _iteratorNormalCompletion27 = true;
  var _didIteratorError27 = false;
  var _iteratorError27 = undefined;

  try {
    for (var _iterator27 = changelog[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
      var log = _step27.value;

      if (txids.indexOf(log.txid) !== -1) {
        filtered_changelog.push(log);
      } else if (txids.indexOf(log.data.s3) !== -1) {
        filtered_changelog.push(log);
      }
    }
  } catch (err) {
    _didIteratorError27 = true;
    _iteratorError27 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion27 && _iterator27["return"] != null) {
        _iterator27["return"]();
      }
    } finally {
      if (_didIteratorError27) {
        throw _iteratorError27;
      }
    }
  }

  return filtered_changelog;
} // https://medium.com/@Dragonza/four-ways-to-chunk-an-array-e19c889eac4


function chunk(array, size) {
  var chunked_arr = [];

  var copied = _toConsumableArray(array); // ES6 destructuring


  var numOfChild = Math.ceil(copied.length / size); // Round up to the nearest integer

  for (var i = 0; i < numOfChild; i++) {
    chunked_arr.push(copied.splice(0, size));
  }

  return chunked_arr;
} // Given results, extend it with bmedia results


function fetch_raw_txid_results(rows) {
  var results = processOpenDirectoryTransactions(rows);
  var already_found = new Set(results.map(function (r) {
    return r.txid;
  }));
  var txids = new Set(results.map(function (r) {
    if (r.bmedia_txid) {
      if (!already_found.has(r.bmedia_txid)) {
        return r.bmedia_txid;
      }
    }
  }).filter(function (r) {
    return r;
  }));
  console.log("fetching", txids.size, "additional bmedia txids");
  return new Promise(function (resolve, reject) {
    fetch_txids_from_network(txids).then(function (bmedia_rows) {
      console.log("found", bmedia_rows.length, "bmedia txids");
      var all_rows = rows.concat(bmedia_rows);
      var sorted = all_rows.sort(function (a, b) {
        return (a.height === null) - (b.height === null) || +(a.height > b.height) || -(a.height < b.height);
      });
      var items = new Map();
      var _iteratorNormalCompletion28 = true;
      var _didIteratorError28 = false;
      var _iteratorError28 = undefined;

      try {
        for (var _iterator28 = sorted[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
          var item = _step28.value;
          var matched_item = items[item.txid];

          if (!matched_item || matched_item && !matched_item.height) {
            items.set(item.txid, item);
          }
        }
      } catch (err) {
        _didIteratorError28 = true;
        _iteratorError28 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion28 && _iterator28["return"] != null) {
            _iterator28["return"]();
          }
        } finally {
          if (_didIteratorError28) {
            throw _iteratorError28;
          }
        }
      }

      var values = Array.from(items.values());
      resolve(values);
    });
  });
}

function fetch_raw_protocol_results() {
  return new Promise(function (resolve, reject) {
    fetch_from_network(null, 0, 10000, [], false).then(function (rows) {
      if (rows.lenth == 0) {
        reject("unable to fetch valid data from network");
      } else if (rows.length < 100) {
        reject("unable to fetch enough valid data from network");
      } else {
        console.log("successfully fetched from the network");
        resolve(rows);
      }
    })["catch"](reject);
  });
}

function fetch_raw_results() {
  return new Promise(function (resolve, reject) {
    fetch_raw_protocol_results().then(function (results) {
      console.log("found", results.length, "raw protocol results");
      fetch_raw_txid_results(results).then(resolve);
    })["catch"](function (e) {
      console.log("ERROR", e);
    });
  });
}

if (typeof window == "undefined") {
  module.exports = {
    "OPENDIR_PROTOCOL": OPENDIR_PROTOCOL,
    "OPENDIR_ACTIONS": OPENDIR_ACTIONS,
    "fetch_from_network": fetch_from_network,
    "fetch_txids_from_network": fetch_txids_from_network,
    "processResults": processResults,
    "processRawResults": processRawResults,
    "processOpenDirectoryTransactions": processOpenDirectoryTransactions,
    "calculateTipchainSplits": calculateTipchainSplits,
    "calculateTipPayment": calculateTipPayment,
    "findObjectByTX": findObjectByTX,
    "connect_to_bitdb_socket": connect_to_bitdb_socket,
    "addNewRowsToExistingRows": addNewRowsToExistingRows,
    "buildItemSliceRepresentationFromCache": buildItemSliceRepresentationFromCache,
    "buildRawSliceRepresentationFromCache": buildRawSliceRepresentationFromCache,
    "fetch_raw_txid_results": fetch_raw_txid_results,
    "fetch_raw_protocol_results": fetch_raw_protocol_results,
    "fetch_raw_results": fetch_raw_results
  };
}
"use strict";

function updateBitcoinSVPrice() {
  // check if we have a cached version
  var storage = window.localStorage;
  var cache = storage["bsv_price_cache"];

  if (cache) {
    try {
      var obj = JSON.parse(cache);
      var price = obj.price;
      var date = obj.date;

      if (price && date) {
        var now = new Date().getTime();
        var diff = now - date;
        var MAX_CACHE_SECONDS = 60 * 60 * 12; // update every 12 hours

        BSV_PRICE = price; // set cached price—better than nothing

        if (diff < MAX_CACHE_SECONDS * 1000) {
          console.log("Using cached Bitcoin SV price of", price);
          return;
        } else {
          console.log("Bitcoin SV price cache is old....updating");
        }
      }
    } catch (e) {
      console.log("Error parsing Bitcoin SV price cache", e);
    }
  }

  getLatestBitcoinSVPrice().then(function (price) {
    if (price > 0) {
      console.log("Updating BSV price from", BSV_PRICE, "to", price);
      BSV_PRICE = price;
      storage["bsv_price_cache"] = JSON.stringify({
        "price": price,
        "date": new Date().getTime()
      });
    }
  })["catch"](function (e) {
    console.log("Error while fetching BSV price", e);
  });
}

function getLatestBitcoinSVPrice() {
  return new Promise(function (resolve, reject) {
    getBitcoinSVPriceFromCoinGecko().then(resolve)["catch"](function (e) {
      console.log("Error while fetching BSV price", e);
      getBitcoinSVPriceFromCryptonator().then(resolve)["catch"](function (e) {
        console.log("Error while fetching BSV price", e);
        getBitcoinSVPriceFromCoinMarketCap().then(resolve)["catch"](reject);
      });
    });
  });
}

function getBitcoinSVPriceFromCoinMarketCap() {
  var url = "https://cors-anywhere.herokuapp.com/https://api.coinmarketcap.com/v1/ticker/bitcoin-sv/";
  return new Promise(function (resolve, reject) {
    fetch(url).then(function (r) {
      if (r.status !== 200) {
        reject("Error while retrieving response from CoinMarketCap server " + r.status);
        return;
      }

      return r.json();
    }).then(function (data) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var result = _step.value;

          if (result["id"] == "bitcoin-sv") {
            var price = Number(result.price_usd);

            if (price > 0) {
              resolve(price);
              return;
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      reject("Error while parsing response from CoinMarketCap price API");
    })["catch"](reject);
  });
}

function getBitcoinSVPriceFromCryptonator() {
  var url = "https://cors.io/?https://api.cryptonator.com/api/ticker/bsv-usd";
  return new Promise(function (resolve, reject) {
    fetch(url).then(function (r) {
      if (r.status !== 200) {
        reject("Error while retrieving response from Cryptonator server " + r.status);
        return;
      }

      return r.json();
    }).then(function (data) {
      if (data["ticker"] && data["ticker"]["price"]) {
        var price = Number(data["ticker"]["price"]);

        if (price > 0) {
          resolve(price);
          return;
        }
      }

      reject("Error while parsing response from Crytponator price API");
    })["catch"](reject);
  });
}

function getBitcoinSVPriceFromCoinGecko() {
  var bsv_id = "bitcoin-cash-sv";
  var url = "https://api.coingecko.com/api/v3/simple/price?ids=" + bsv_id + "&vs_currencies=USD";
  return new Promise(function (resolve, reject) {
    fetch(url).then(function (r) {
      if (r.status !== 200) {
        reject("Error while retrieving response from CoinGecko server " + r.status);
        return;
      }

      return r.json();
    }).then(function (data) {
      if (data[bsv_id] && data[bsv_id]["usd"]) {
        var price = Number(data[bsv_id]["usd"]);

        if (price > 0) {
          resolve(price);
          return;
        }
      }

      reject("Error while parsing response from coingecko price API");
    })["catch"](reject);
  });
}
"use strict";

var ALLOWED_ACTIONS = ["uri", "attach", "detach"];

function fetchAdminActions(admin_address) {
  var query = {
    "v": 3,
    "sort": {
      "txid": 1
    },
    "q": {
      "find": {
        "out.s1": admin_address,
        "in.e.a": admin_address
      },
      "limit": 9999 // can eventually do paging here if necessary, admin log should stay small though

    },
    "r": {
      "f": "[.[] | {                  \
                \"height\": .blk.i?,        \
                \"time\": .blk.t?,        \
                \"address\": .in[0].e.a,    \
                \"txid\": .tx.h,            \
                \"data\": .out[0] | with_entries(select(((.key | startswith(\"s\")) and (.key != \"str\"))))}]"
    }
  };
  var encoded_query = toBase64(JSON.stringify(query));
  var api_url = SETTINGS["api_endpoint"].replace("{api_key}", SETTINGS.api_key).replace("{api_action}", "q");
  ;
  var url = api_url.replace("{query}", encoded_query);
  var header = {
    headers: {
      key: SETTINGS.api_key
    }
  };
  return new Promise(function (resolve, reject) {
    if (!admin_address) {
      reject("invalid admin address");
      return;
    }

    console.log("Fetching admin actions for admin protocol", admin_address);
    fetch(url, header).then(function (r) {
      if (!r) {
        reject("Error response while checking updater");
      } else if (r.status !== 200) {
        reject("Error response status code while checking updater " + r.status);
      } else {
        r.json().then(function (data) {
          var results = data.c.concat(data.u);
          var sorted = results.sort(function (a, b) {
            return (a.height === null) - (b.height === null) || +(a.height > b.height) || -(a.height < b.height);
          });
          resolve(sorted);
        });
      }
    });
  });
}

function getCachedAdminActions() {
  var cache_mins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 60;
  return new Promise(function (resolve, reject) {
    var now = new Date().getTime();
    var cache_key = "admin_actions_" + SETTINGS.admin_address;
    var cache = lscache.get(cache_key);

    if (cache) {
      return resolve(cache);
    }

    fetchAdminActions(SETTINGS.admin_address).then(function (results) {
      if (results) {
        lscache.set(cache_key, results, cache_mins);
      }

      resolve(results);
    })["catch"](reject);
  });
}

function processAdminResult(result) {
  var action = result.data.s2;

  if (ALLOWED_ACTIONS.indexOf(action) == -1) {
    return null;
  }

  var object = {
    "type": "admin",
    "height": result.height,
    "address": result.address,
    "txid": result.txid,
    "time": result.time,
    "action": action,
    "data": result.data
  };

  if (action == "uri") {
    var uri = result.data.s3;
    object.uri = uri;
  } else if (action == "attach" || action == "detach") {
    object.action_id = result.data.s3;
  }

  return object;
}

function processAdminResults(results) {
  return results.map(processAdminResult).filter(function (r) {
    return r;
  });
}

function fetchLog() {
  return new Promise(function (resolve, reject) {
    getCachedAdminActions().then(function (results) {
      resolve(processAdminResults(results));
    })["catch"](reject);
  });
}

function fetchURIs() {
  return new Promise(function (resolve, reject) {
    getCachedAdminActions().then(function (raw) {
      var results = processAdminResults(raw);
      var uris = results.filter(function (r) {
        return r.action == "uri";
      });
      resolve(uris);
    })["catch"](reject);
  });
}

function fetchAttachAndDetaches() {
  return new Promise(function (resolve, reject) {
    getCachedAdminActions().then(function (raw) {
      var results = processAdminResults(raw);
      var filtered = results.filter(function (r) {
        return r.action == "attach" || r.action == "detach";
      });
      resolve(filtered);
    })["catch"](reject);
  });
}

function getLatestUpdate() {
  return new Promise(function (resolve, reject) {
    return fetchURIs().then(function (actions) {
      if (actions && actions.length > 0) {
        resolve(actions[actions.length - 1]);
      }
    });
  });
}
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var SearchPage =
/*#__PURE__*/
function (_React$Component) {
  _inherits(SearchPage, _React$Component);

  function SearchPage(props) {
    var _this;

    _classCallCheck(this, SearchPage);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SearchPage).call(this, props));
    _this.state = {
      "search": ""
    };
    return _this;
  }

  _createClass(SearchPage, [{
    key: "handleSearch",
    value: function handleSearch(e) {
      this.setState({
        "search": e.target.value
      });
    }
  }, {
    key: "render",
    value: function render() {
      return React.createElement("div", {
        className: "search"
      }, React.createElement(SearchForm, {
        search: this.state.search,
        title: this.props.title,
        onSearch: this.handleSearch.bind(this),
        category: this.props.category,
        embed: this.props.embed,
        changeURL: this.props.changeURL
      }), this.state.search && React.createElement(SearchResults, {
        search: this.state.search,
        items: this.props.items,
        changeURL: this.props.changeURL
      }));
    }
  }]);

  return SearchPage;
}(React.Component);

var SearchForm =
/*#__PURE__*/
function (_React$Component2) {
  _inherits(SearchForm, _React$Component2);

  function SearchForm() {
    _classCallCheck(this, SearchForm);

    return _possibleConstructorReturn(this, _getPrototypeOf(SearchForm).apply(this, arguments));
  }

  _createClass(SearchForm, [{
    key: "handleSubmit",
    value: function handleSubmit(e) {
      e.preventDefault();
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var searching;

      if (this.props.category && this.props.category.name) {
        searching = React.createElement("span", null, "Search ", React.createElement("a", {
          onClick: function onClick() {
            _this2.props.changeURL("/category/" + _this2.props.category.txid);
          }
        }, this.props.category.name));
      } else if (this.props.category && this.props.category.txid) {
        searching = React.createElement("span", null, "Search category ", this.props.category.txid.slice(0, 5), "...");
      } else if (this.props.category && !this.props.category.txid) {
        searching = React.createElement("span", null, "Search ", React.createElement("a", {
          onClick: function onClick() {
            _this2.props.changeURL("/");
          }
        }, "Open Directory"));
      }

      if (this.props.embed) {
        return React.createElement("div", {
          className: "search embed"
        }, React.createElement("form", {
          onSubmit: this.handleSubmit.bind(this)
        }, React.createElement("input", {
          type: "search",
          value: this.props.search,
          onChange: this.props.onSearch.bind(this),
          placeholder: "Search the Open Directory..."
        }), React.createElement("input", {
          type: "submit",
          className: "button-outline",
          value: "Search"
        })));
      } else {
        return React.createElement("div", {
          className: "search page"
        }, React.createElement("h2", null, searching), React.createElement("p", {
          className: "blurb"
        }, "Search by name, description, link, txid, address..."), React.createElement("form", {
          onSubmit: this.handleSubmit.bind(this)
        }, React.createElement("input", {
          type: "search",
          value: this.props.search,
          onChange: this.props.onSearch.bind(this)
        }), React.createElement("input", {
          type: "submit",
          className: "button-outline",
          value: "Search"
        })));
      }
    }
  }]);

  return SearchForm;
}(React.Component);

var SearchResults =
/*#__PURE__*/
function (_React$Component3) {
  _inherits(SearchResults, _React$Component3);

  function SearchResults(props) {
    var _this3;

    _classCallCheck(this, SearchResults);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(SearchResults).call(this, props));
    _this3.state = {
      "limit": 15,
      "cursor": 0
    };
    return _this3;
  }

  _createClass(SearchResults, [{
    key: "handlePageChange",
    value: function handlePageChange(page) {
      var idx = page - 1;
      var cursor = idx * this.state.limit;
      this.setState({
        "cursor": cursor
      });
      window.scrollTo(0, 250);
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var search = this.props.search.toLowerCase();
      var results = this.props.items.filter(function (item) {
        if (item.deleted) {
          return false;
        }

        if (item.name && item.name.toLowerCase().indexOf(search) !== -1) {
          return true;
        }

        if (item.description && item.description.toLowerCase().indexOf(search) !== -1) {
          return true;
        }

        if (item.txid && item.txid.toLowerCase().indexOf(search) !== -1) {
          return true;
        }

        if (item.address && item.address.toLowerCase().indexOf(search) !== -1) {
          return true;
        }

        if (item.link && item.link.toLowerCase().indexOf(search) !== -1) {
          return true;
        }

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = item.tipchain[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var tipchain = _step.value;

            if (tipchain.address.toLowerCase().indexOf(search) !== -1) {
              return true;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return false;
      });
      var sorted = results.sort(function (a, b) {
        if (a.hottness < b.hottness) {
          return 1;
        }

        if (a.hottness > b.hottness) {
          return -1;
        }

        if (a.satoshis < b.satoshis) {
          return 1;
        }

        if (a.satoshis > b.satoshis) {
          return -1;
        }

        if (a.votes < b.votes) {
          return 1;
        }

        if (a.votes > b.votes) {
          return -1;
        }

        if (a.height < b.height) {
          return 1;
        }

        if (a.height > b.height) {
          return -1;
        }

        return 0;
      });
      var slice = sorted.slice(this.state.cursor, this.state.cursor + this.state.limit);
      var numPages = Math.ceil(results.length / this.state.limit);

      var pages = _toConsumableArray(Array(numPages).keys()).map(function (idx) {
        var page = idx + 1;
        return React.createElement("a", {
          key: "page-" + page,
          className: _this4.state.cursor == idx * _this4.state.limit ? "active" : null,
          onClick: function onClick() {
            _this4.handlePageChange(page);
          }
        }, page);
      });

      return React.createElement("div", null, React.createElement("ul", {
        className: "search-results"
      }, slice.map(function (result) {
        return React.createElement(SearchResult, {
          key: result.txid,
          item: result,
          items: _this4.props.items,
          changeURL: _this4.props.changeURL
        });
      })), React.createElement("p", {
        className: "num-results"
      }, "Found ", pluralize(results.length, "result", "results")), pages.length > 1 && React.createElement("div", {
        className: "pages"
      }, pages));
    }
  }]);

  return SearchResults;
}(React.Component);

var SearchResult =
/*#__PURE__*/
function (_React$Component4) {
  _inherits(SearchResult, _React$Component4);

  function SearchResult() {
    _classCallCheck(this, SearchResult);

    return _possibleConstructorReturn(this, _getPrototypeOf(SearchResult).apply(this, arguments));
  }

  _createClass(SearchResult, [{
    key: "render",
    value: function render() {
      var _this5 = this;

      if (this.props.item.type == "category") {
        var url;

        if (this.props.item.txid) {
          url = "/category/" + this.props.item.txid;
        } else {
          url = "/";
        }

        return React.createElement("div", {
          className: "search-result"
        }, React.createElement("h4", null, React.createElement("a", {
          onClick: function onClick() {
            _this5.props.changeURL(url);
          }
        }, this.props.item.name), " ", React.createElement("span", {
          className: "badge badge-type-" + this.props.item.type
        }, this.props.item.type)), this.props.item.type == "entry" && React.createElement("a", {
          className: "url",
          href: getLink(this.props.item.link)
        }, this.props.item.link), React.createElement("div", {
          className: "satoshis"
        }, satoshisToDollars(this.props.item.satoshis), " -\xA0", pluralize(this.props.item.votes, "vote", "votes"), " - ", pluralize(this.props.item.entries, "link", "links"), " in category"), React.createElement(ReactMarkdown, {
          source: this.props.item.description
        }));
      } else if (this.props.item.type == "entry") {
        var _url = this.props.item.link;
        var category = findObjectByTX(this.props.item.category, this.props.items);
        return React.createElement("div", {
          className: "search-result"
        }, React.createElement("h4", null, React.createElement("a", {
          href: _url
        }, this.props.item.name), " ", React.createElement("span", {
          className: "badge badge-type-" + this.props.item.type
        }, this.props.item.type), " ", React.createElement("span", {
          className: "from-category-prefix"
        }, "in"), " ", React.createElement("a", {
          className: "from-category",
          onClick: function onClick() {
            _this5.props.changeURL("/category/" + category.txid);
          }
        }, category.name)), this.props.item.type == "entry" && React.createElement("a", {
          className: "url",
          href: getLink(this.props.item.link)
        }, this.props.item.link), React.createElement("div", {
          className: "satoshis"
        }, satoshisToDollars(this.props.item.satoshis), " - ", pluralize(this.props.item.votes, "vote", "votes")), React.createElement(ReactMarkdown, {
          source: this.props.item.description
        }));
      }
    }
  }]);

  return SearchResult;
}(React.Component);
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var TipchainItem =
/*#__PURE__*/
function (_React$Component) {
  _inherits(TipchainItem, _React$Component);

  function TipchainItem(props) {
    var _this;

    _classCallCheck(this, TipchainItem);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TipchainItem).call(this, props));
    _this.state = {
      "showingTipchain": false,
      "tip": SETTINGS["tip_amount"],
      // tipchains can appear in many different contexts, so we don't want to use a entry or category id for the parent, just a random key
      "rand": Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)
    };
    _this.handleTipSubmit = _this.handleTipSubmit.bind(_assertThisInitialized(_this));
    _this.handleClickTip = _this.handleClickTip.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(TipchainItem, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      window.addEventListener('popstate', this.clearMoneyButton.bind(this), false);
      this.handleTipSubmit();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener('popstate', this.clearMoneyButton.bind(this));
    }
  }, {
    key: "clearMoneyButton",
    value: function clearMoneyButton() {
      var container = document.getElementById(this.state.rand);

      if (container) {
        var voteButton = container.querySelector(".tip-money-button");

        if (voteButton) {
          var parentNode = voteButton.parentNode;
          parentNode.removeChild(voteButton);
          var newEl = document.createElement('div');
          newEl.className = "tip-money-button";
          parentNode.appendChild(newEl);
        }
      }
    }
  }, {
    key: "handleTipSubmit",
    value: function handleTipSubmit(e) {
      var _this2 = this;

      if (e) {
        e.preventDefault();
      }

      var OP_RETURN;

      if (this.props.custom_OP_RETURN) {
        OP_RETURN = this.props.custom_OP_RETURN(this.props.item.txid);
      } else {
        OP_RETURN = [OPENDIR_PROTOCOL, "vote", this.props.item.txid];
      }

      if (!OP_RETURN || OP_RETURN.length == 0) {
        return alert("Invalid OP_RETURN generated for tip... please try again or contact the developers");
      }

      console.log("OP_RETURN", OP_RETURN);
      var tipchain = this.get_tipchain();

      if (!tipchain || tipchain.length == 0) {
        if (!confirm("Tipchain is invalid, please refresh or press OK to continue anyway")) {
          return;
        }
      }

      var amount = Number(this.state.tip);
      console.log("tipchain", tipchain);
      var payments = calculateTipPayment(tipchain, amount, SETTINGS.currency);
      console.log("payments", payments);
      var button = document.getElementById(this.state.rand).querySelector(".tip-money-button");
      databutton.build({
        data: OP_RETURN,
        button: {
          $el: button,
          label: "upvote",
          $pay: {
            to: payments
          },
          onPayment: function onPayment(msg) {
            console.log(msg);
            var local_settings = get_local_settings();
            local_settings["tip_amount"] = amount;
            use_local_settings(local_settings);
            save_local_settings(local_settings);
            setTimeout(function () {
              _this2.clearMoneyButton();

              _this2.props.onSuccessHandler();
            }, 5000);
          }
        }
      });
    }
  }, {
    key: "handleClickTip",
    value: function handleClickTip(e) {
      var _this3 = this;

      var amt = e.currentTarget.dataset.value;

      if (amt > 0) {
        this.setState({
          "tip": amt
        }, function () {
          _this3.handleTipSubmit();
        });
      }
    }
  }, {
    key: "handleChangeTip",
    value: function handleChangeTip(e) {
      this.setState({
        "tip": e.target.value
      });
    }
  }, {
    key: "handleClickTipchain",
    value: function handleClickTipchain(e) {
      this.setState({
        "showingTipchain": !this.state.showingTipchain
      });
    }
  }, {
    key: "get_tipchain",
    value: function get_tipchain() {
      return this.props.item.txid == null ? SETTINGS.tip_addresses : this.props.item.tipchain;
    }
  }, {
    key: "render",
    value: function render() {
      var tipchain = expandTipchainInformation(this.get_tipchain(), this.state.tip, this.props.items);
      return React.createElement("div", {
        className: "tipping"
      }, React.createElement("form", {
        onSubmit: this.handleTipSubmit.bind(this)
      }, React.createElement("label", null, "Tip \xA0", React.createElement("a", {
        className: "suggested-tip",
        "data-value": "0.05",
        onClick: this.handleClickTip
      }, "5\xA2"), React.createElement("a", {
        className: "suggested-tip",
        "data-value": "0.10",
        onClick: this.handleClickTip
      }, "10\xA2"), React.createElement("a", {
        className: "suggested-tip",
        "data-value": "0.25",
        onClick: this.handleClickTip
      }, "25\xA2"), React.createElement("a", {
        className: "suggested-tip",
        "data-value": "1.00",
        onClick: this.handleClickTip
      }, "$1.00"), "$"), React.createElement("input", {
        className: "tip",
        type: "text",
        placeholder: "0.05",
        value: this.state.tip,
        onChange: this.handleChangeTip.bind(this)
      }), " ", React.createElement("input", {
        type: "submit",
        className: "button button-outline",
        value: "tip"
      })), React.createElement("hr", null), React.createElement("div", {
        className: "tipchain"
      }, React.createElement("p", null, React.createElement("a", {
        onClick: this.handleClickTipchain.bind(this)
      }, pluralize(tipchain.length, "address", "addresses")), " in this tipchain"), this.state.showingTipchain && React.createElement("ul", null, tipchain.map(function (t, i) {
        var split = (Number(t.split) * 100).toFixed(2);
        var key = i + t.type + t.address + t.split;
        var amount = Number(t.amount).toFixed(2);
        var symbol = "$";

        if (t.amount > 0 && amount == "0.00") {
          amount = Number(t.amount).toFixed(3);
        }

        if (t.type == "opendirectory") {
          return React.createElement("li", {
            key: key
          }, symbol, amount, " to ", React.createElement("strong", null, t.name), " ", t.address);
        } else if (t.type == "media") {
          return React.createElement("li", {
            key: key
          }, symbol, amount, " to original content owner ", React.createElement("strong", null, t.address));
        } else if (t.type == "category") {
          return React.createElement("li", {
            key: key
          }, symbol, amount, " to ", React.createElement("strong", null, t.name), " category creator ", t.address);
        } else if (t.type == "entry") {
          return React.createElement("li", {
            key: key
          }, symbol, amount, " to ", React.createElement("strong", null, t.name), " entry submitter ", t.address);
        } else {
          return React.createElement("li", {
            key: key
          }, symbol, amount, " ", React.createElement("strong", null, t.name), " ", t.address);
        }
      })), React.createElement("div", {
        className: "money-button-wrapper",
        id: this.state.rand
      }, React.createElement("div", {
        className: "tip-money-button"
      }))));
    }
  }]);

  return TipchainItem;
}(React.Component);
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var DeleteItem =
/*#__PURE__*/
function (_React$Component) {
  _inherits(DeleteItem, _React$Component);

  function DeleteItem(props) {
    var _this;

    _classCallCheck(this, DeleteItem);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DeleteItem).call(this, props));
    _this._isMounted = false;
    _this.state = {
      delete_reason: ""
    };
    return _this;
  }

  _createClass(DeleteItem, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this._isMounted = true;
      window.addEventListener('popstate', this.clearMoneyButton.bind(this), false);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._isMounted = false;
      window.removeEventListener('popstate', this.clearMoneyButton.bind(this));
    }
  }, {
    key: "clearMoneyButton",
    value: function clearMoneyButton() {
      if (this._isMounted) {
        var container = document.getElementById(this.props.item.txid);

        if (container) {
          var deleteButton = container.querySelector(".delete-money-button");

          if (deleteButton) {
            var parentNode = deleteButton.parentNode;
            parentNode.removeChild(deleteButton);
            var newEl = document.createElement('div');
            newEl.className = "delete-money-button";
            parentNode.appendChild(newEl);
          }
        }
      }
    }
  }, {
    key: "handleDelete",
    value: function handleDelete(e) {
      var _this2 = this;

      e.preventDefault();
      var action = this.props.item.type + ".delete";
      var OP_RETURN = [OPENDIR_PROTOCOL, action, this.props.item.txid];

      if (this.state.delete_reason) {
        OP_RETURN.push(this.state.delete_reason);
      } else {
        if (!confirm("Are you sure you want to continue? You didn't specify a reason for deletion.\n\nProviding a reason helps everyone understand your thinking behind this change, and can prevent it from being reverted in the future.")) {
          return;
        }
      }

      console.log(OP_RETURN);
      var button = document.getElementById(this.props.item.txid).querySelector(".delete-money-button");
      databutton.build({
        data: OP_RETURN,
        button: {
          $el: button,
          onPayment: function onPayment(msg) {
            console.log(msg);
            setTimeout(function () {
              _this2.setState({
                "delete_reason": ""
              });

              _this2.clearMoneyButton();

              _this2.props.onSuccessHandler();
            }, 5000);
          }
        }
      });
    }
  }, {
    key: "handleChangeDeleteReason",
    value: function handleChangeDeleteReason(e) {
      this.setState({
        "delete_reason": e.target.value
      });
    }
  }, {
    key: "render",
    value: function render() {
      var msg = "If you remove this " + this.props.item.type + " you'll be permanently removing it from this directory for others to view. Please only do this if you think it's in the best interest of the directory. Your Bitcoin key is forever tied to this transaction, so it will always be traced to you.";
      return React.createElement("div", {
        className: "notice"
      }, React.createElement("span", {
        className: "warning"
      }, "You are about to delete this ", this.props.item.type, ", are you sure you want to do this?"), React.createElement("div", {
        className: "explain"
      }, React.createElement("p", null, msg), React.createElement("p", null, React.createElement("strong", null, "What are you deleting this ", this.props.item.type, "?")), React.createElement("form", {
        onSubmit: this.handleDelete.bind(this)
      }, React.createElement("input", {
        type: "text",
        placeholder: "reason for delete",
        value: this.state.delete_reason,
        onChange: this.handleChangeDeleteReason.bind(this)
      }), " ", React.createElement("input", {
        type: "submit",
        className: "button button-outline",
        value: "delete"
      })), React.createElement("div", {
        className: "delete-money-button"
      })));
    }
  }]);

  return DeleteItem;
}(React.Component);
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Item =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Item, _React$Component);

  function Item(props) {
    var _this;

    _classCallCheck(this, Item);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Item).call(this, props));
    _this.state = {
      "isExpanded": false,
      "action": null
    };
    _this._isMounted = false;
    return _this;
  }

  _createClass(Item, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this._isMounted = true;
      window.addEventListener('popstate', this.clearForm.bind(this), false);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._isMounted = false;
      window.removeEventListener('popstate', this.clearForm.bind(this));
    } // hack for scale during launch

  }, {
    key: "getLocation",
    value: function getLocation() {
      return window.location.hash.replace(/^#\/?|\/$/g, '').split('/');
    }
  }, {
    key: "handleSuccessfulTip",
    value: function handleSuccessfulTip() {
      this.setState({
        "action": null
      });

      if (this.props.item.type == "category") {
        var location = this.getLocation();

        if (location.length == 0) {
          this.props.onSuccessHandler("Successfully upvoted " + this.props.item.type + ", due to high demand we've cached the homepage for 1 minute. Please refresh after that time to see your upvote. We're working hard on a fix!");
          return;
        }
      }

      this.props.onSuccessHandler("Successfully upvoted " + this.props.item.type + ", it will appear automatically—please refresh the page if it doesn't");
    }
  }, {
    key: "handleSuccessfulDelete",
    value: function handleSuccessfulDelete() {
      this.setState({
        "action": null
      });
      this.props.onSuccessHandler("Successfully deleted " + this.props.item.type + ", it will appear automatically—please refresh the page if it doesn't");
    }
  }, {
    key: "clearForm",
    value: function clearForm() {
      if (this._isMounted) {
        this.setState({
          "isExpanded": false,
          "action": null
        });
      }
    }
  }, {
    key: "handleUpvote",
    value: function handleUpvote(e) {
      this.setState({
        "action": "tipping"
      });
    }
  }, {
    key: "handleToggleExpand",
    value: function handleToggleExpand(e) {
      this.setState({
        "isExpanded": !this.state.isExpanded,
        "action": null
      });
    }
  }, {
    key: "handleEdit",
    value: function handleEdit(e) {
      this.setState({
        "action": "editing"
      });
    }
  }, {
    key: "handleDelete",
    value: function handleDelete(e) {
      this.setState({
        "action": "deleting"
      });
    }
  }]);

  return Item;
}(React.Component);
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Fork =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Fork, _React$Component);

  function Fork(props) {
    var _this;

    _classCallCheck(this, Fork);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Fork).call(this, props));
    _this.state = {
      "action": null,
      "fork_address": null,
      "tip_addresses": JSON.parse(JSON.stringify(SETTINGS.tip_addresses)),
      "admin_address": SETTINGS.admin_address
    };
    return _this;
  }

  _createClass(Fork, [{
    key: "validate",
    value: function validate() {
      if (this.state.tip_addresses.length == 0) {
        if (!confirm("The tipchain doesn't have any addresses, are you sure you want to continue?")) {
          return false;
        }
      }

      if (!bsv.Address.isValid(this.state.admin_address)) {
        alert("The admin address doesn't look valid, please use a Bitcom generated address through the admin console");
        return false;
      }

      if (this.state.admin_address == SETTINGS.admin_address) {
        if (!confirm("The admin address hasn't changed—you won't be able to admin this directory if you don't control this address. Are you sure you want to continue?")) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "prepareOPReturnForPingback",
    value: function prepareOPReturnForPingback() {
      if (!this.state.fork_address) {
        alert("Invalid fork address....please try again");
        return;
      }

      if (SETTINGS.category) {
        return [OPENDIR_PROTOCOL, "fork.soft", this.state.fork_address, SETTINGS.category];
      } else {
        return [OPENDIR_PROTOCOL, "fork.soft", this.state.fork_address];
      }
    }
  }, {
    key: "fetchTemplateByTXID",
    value: function fetchTemplateByTXID(txid) {
      var query = {
        "v": 3,
        "sort": {
          "txid": 1
        },
        "q": {
          "find": {
            "tx.h": txid
          },
          "limit": 1
        },
        "r": {
          "f": "[.[] | {                  \
                \"height\": .blk.i?,        \
                \"time\": .blk.t?,        \
                \"address\": .in[0].e.a,    \
                \"txid\": .tx.h,            \
                \"data\": .out[0]}]"
        }
      };
      var encoded_query = toBase64(JSON.stringify(query));
      var api_url = SETTINGS["api_endpoint"].replace("{api_key}", SETTINGS.api_key).replace("{api_action}", "q");
      ;
      var url = api_url.replace("{query}", encoded_query);
      var header = {
        headers: {
          key: SETTINGS.api_key
        }
      };
      return new Promise(function (resolve, reject) {
        console.log("Fetching template for txid", txid);
        fetch(url, header).then(function (r) {
          if (!r) {
            reject("Error response while fetching template");
          } else if (r.status !== 200) {
            reject("Error response status code while fetching template" + r.status);
          } else {
            r.json().then(function (data) {
              var results = data.c.concat(data.u);

              if (results.length == 0) {
                reject("Couldn't find template with txid " + txid);
              } else if (results.length > 1) {
                reject("Found too many templates for " + txid);
              } else {
                resolve(results[0]);
              }
            });
          }
        });
      });
    }
  }, {
    key: "handleSubmit",
    value: function handleSubmit(e) {
      var _this2 = this;

      e.preventDefault();

      if (!this.validate()) {
        return;
      }

      var template_txid = this.props.template_txid;

      if (!template_txid) {
        template_txid = prompt("We didn't detect a template_txid — this is a b:// file that gets replicated when forking. Please enter one now to continue", "enter template txid");

        if (!template_txid) {
          return;
        }
      }

      this.fetchTemplateByTXID(template_txid).then(function (template_tx) {
        if (!template_tx) {
          throw "Error while fetching template during fork, please try again";
        }

        var data = template_tx.data;

        if (data.s1 !== B_MEDIA_PROTOCOL && data.s3.toLowerCase() !== "text/html" && data.s4.toLowerCase() !== "utf-8") {
          throw "Unknown template protocol, only b:// HTML templates currently supported";
        }

        if (data.ls2.indexOf("<!-- BEGIN SETTINGS -->") == -1) {
          throw "Missing <!-- BEGIN SETTINGS --> marker in template tag";
        }

        if (data.ls2.indexOf("<!-- END SETTINGS -->") == -1) {
          throw "Missing <!-- END SETTINGS --> marker in template tag";
        }

        var OP_RETURN = [data.s1, data.ls2, data.s3, data.s4, data.s5];
        var new_settings = Object.assign({}, SETTINGS, {
          "faq_markdown": _this2.props.faqMarkdown,
          "intro_markdown": _this2.props.introMarkdown,
          "theme": _this2.props.theme,
          "tip_addresses": _this2.state.tip_addresses,
          "admin_address": _this2.state.admin_address,
          "title": _this2.props.title,
          "tip_amount": 0.05 // TODO: Make configurable in admin

        });
        var new_html_settings = "<!-- BEGIN SETTINGS -->\n<script>var SETTINGS = " + JSON.stringify(new_settings, null, 4) + ";</script>\n<!-- END SETTINGS -->";
        var new_html = data.ls2.replace(/\<\!\-\- BEGIN SETTINGS \-\-\>((.|[\n|\r|\r\n])*?)\<\!\-\- END SETTINGS \-\-\>[\n|\r|\r\n]?(\s+)?/g, new_html_settings);
        console.log("NEW_SETTINGS", new_html_settings);
        console.log("NEW_HTML", new_html);
        OP_RETURN[1] = new_html;
        OP_RETURN[4] = _this2.props.title;
        console.log("OP_RETURN", OP_RETURN);

        _this2.setState({
          "action": "forking"
        }, function () {
          var el = document.querySelector(".fork-money-button");
          databutton.build({
            data: OP_RETURN,
            button: {
              $el: el,
              onPayment: function onPayment(msg) {
                _this2.handleForkResponse(msg.txid);
              }
            }
          });
        });
      })["catch"](function (e) {
        console.log("error", e);

        _this2.props.onErrorHandler("Error while fetching template during fork, please try again");
      });
    }
  }, {
    key: "handleForkResponse",
    value: function handleForkResponse(txid) {
      if (!txid) {
        alert("There was an error while forking—we didn't receive a valid txid. Please try again or contact the developers");
        return;
      }

      console.log("Successfully forked to txid", txid);
      var url = getBitLinkForBMediaTXID(txid);
      console.log("Forked to", url);
      this.setState({
        "action": "post-fork",
        "fork_address": url
      }, function () {});
    }
  }, {
    key: "removeTipChainTip",
    value: function removeTipChainTip(address) {
      var tip_addresses = this.state.tip_addresses.filter(function (tip) {
        return tip.address !== address;
      });
      this.setState({
        "tip_addresses": tip_addresses
      });
    }
  }, {
    key: "handleChangeForkType",
    value: function handleChangeForkType() {
      console.log("CHANGE FORK TYPE");
    }
  }, {
    key: "handleAddAddressToTipchain",
    value: function handleAddAddressToTipchain() {
      this.setState({
        "action": "adding-tip-address"
      });
    }
  }, {
    key: "handleCancelAddingAddressToTipchain",
    value: function handleCancelAddingAddressToTipchain() {
      this.setState({
        "action": null
      });
    }
  }, {
    key: "handleAddTipchainAddress",
    value: function handleAddTipchainAddress(address) {
      if (!address.address) {
        return alert("Please enter a valid tip address");
      }

      if (!bsv.Address.isValid(address.address)) {
        return alert("This Bitcoin address is not valid, please check and try again");
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.state.tip_addresses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var tip_address = _step.value;

          if (tip_address.address == address.address) {
            return alert("This address is already listed in the tipchain, try adding a different one");
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (!address.name) {
        return alert("Please enter a name for this address, it will help people understand where they're sending money");
      }

      var tip_addresses = this.state.tip_addresses;
      tip_addresses.push(address);
      this.setState({
        "action": null,
        "tip_addresses": tip_addresses
      });
    }
  }, {
    key: "handleChangeAdminAddress",
    value: function handleChangeAdminAddress(e) {
      this.setState({
        "admin_address": e.target.value
      });
    }
  }, {
    key: "handleCategoryChange",
    value: function handleCategoryChange(e) {
      var txid = e.target.value;

      if (txid == "") {
        txid = null;
      }

      this.props.onChangeCategory(txid);
    }
  }, {
    key: "handleSuccessfulTip",
    value: function handleSuccessfulTip() {
      this.setState({
        "action": "post-ping"
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var splits = calculateTipchainSplits(this.state.tip_addresses);
      var opendir_tips = JSON.parse(JSON.stringify(this.state.tip_addresses)); // hacky deep copy

      for (var i = 0; i < opendir_tips.length; i++) {
        opendir_tips[i].split = splits[i];
      }

      var select_value = SETTINGS.category ? SETTINGS.category : "";
      var selected_category = this.props.items.filter(function (i) {
        return i.txid == select_value;
      }).unshift();
      var categories = this.props.items.filter(function (i) {
        return i.type == "category";
      });
      categories.unshift({
        "txid": "",
        "name": "Open Directory"
      });
      return React.createElement("div", {
        className: "fork"
      }, React.createElement("a", {
        className: "close",
        onClick: this.props.onCloseFork
      }, "X"), React.createElement("h2", null, React.createElement("i", {
        className: "fas fa-code-branch"
      }), " Fork"), React.createElement("p", null, "Forking allows you to take control of a directory\u2014to be the admin, change the theme, insert yourself in the tipchain\u2014whatever you want."), React.createElement("form", {
        onSubmit: this.handleSubmit.bind(this)
      }, React.createElement("fieldset", null, React.createElement("div", {
        className: "row compressed form-item"
      }, React.createElement("div", {
        className: "column"
      }, React.createElement("label", null, React.createElement("input", {
        type: "radio",
        value: "soft",
        checked: "checked",
        onChange: this.handleChangeForkType.bind(this)
      }), " Soft Fork ", React.createElement("span", {
        className: "desc"
      }, "\u2014 fork application")), React.createElement("label", null, React.createElement("input", {
        type: "radio",
        value: "soft",
        disabled: "disabled",
        onChange: this.handleChangeForkType.bind(this)
      }), " Hard Fork ", React.createElement("span", {
        className: "desc"
      }, "\u2014 fork data (coming soon)")))), React.createElement("div", {
        className: "row form-item"
      }, React.createElement("div", {
        className: "column"
      }, React.createElement("label", null, "Category"), React.createElement("p", null, "Select the category you want to fork. It will be published to the blockchain with a new Bitcoin URL where everyone can access it with the changes you've made. You can even fork the entire Open Directory."), React.createElement("select", {
        onChange: this.handleCategoryChange.bind(this),
        value: select_value
      }, categories.map(function (category) {
        return React.createElement("option", {
          value: category.txid,
          key: category.txid
        }, category.name);
      })))), React.createElement("div", {
        className: "row form-item"
      }, React.createElement("div", {
        className: "column"
      }, React.createElement("label", null, "Admin Address"), React.createElement("p", null, "Set the address that gets special rights, like notifying users about updated versions and detatching directories. ", React.createElement("a", {
        href: "https://github.com/synfonaut/OpenDirectory-Admin-Console",
        target: "_blank"
      }, "Generate an Open Directory Admin Address")), React.createElement("input", {
        type: "text",
        value: this.state.admin_address,
        onChange: this.handleChangeAdminAddress.bind(this)
      }))), React.createElement("div", {
        className: "row form-item"
      }, React.createElement("div", {
        className: "column"
      }, React.createElement("label", null, "Default Tipchain"), React.createElement("p", null, "Specify which addresses get included in the tipchain"), React.createElement("table", {
        className: "tipchain"
      }, React.createElement("tbody", null, opendir_tips.map(function (tip, i) {
        return React.createElement("tr", {
          key: i,
          id: tip.address
        }, React.createElement("td", {
          className: "name"
        }, React.createElement("strong", null, tip.name), React.createElement("br", null), tip.address), React.createElement("td", {
          className: "percentage"
        }, numberFormat(tip.split * 100, 2), "%"), React.createElement("td", {
          className: "remove"
        }, React.createElement("a", {
          onClick: function onClick() {
            _this3.removeTipChainTip(tip.address);
          }
        }, "x")));
      }), this.state.action != "adding-tip-address" && React.createElement("tr", null, React.createElement("td", {
        className: "add",
        colSpan: "3"
      }, React.createElement("a", {
        onClick: this.handleAddAddressToTipchain.bind(this)
      }, "Add address to tipchain"))), this.state.action == "adding-tip-address" && React.createElement("tr", null, React.createElement("td", {
        className: "add",
        colSpan: "3"
      }, React.createElement(AddTipchainAddressForm, {
        onSubmit: this.handleAddTipchainAddress.bind(this),
        onCancel: this.handleCancelAddingAddressToTipchain.bind(this)
      }))))))), React.createElement("div", {
        className: "row form-item"
      }, React.createElement("div", {
        className: "column"
      }, React.createElement("label", null, "Title"), React.createElement("p", null, "What is the name of your directory?"), React.createElement("input", {
        type: "text",
        value: this.props.title,
        onChange: this.props.onChangeTitle
      }))), React.createElement("div", {
        className: "row form-item"
      }, React.createElement("div", {
        className: "column"
      }, React.createElement("label", null, "Theme"), React.createElement("p", null, "Select a color scheme"), React.createElement("div", {
        className: "row select-a-theme"
      }, React.createElement("div", {
        className: "column"
      }, React.createElement("a", {
        className: this.props.theme == "orange-theme" ? "active select-theme orange" : "select-theme orange",
        onClick: function onClick() {
          _this3.props.onChangeTheme("orange-theme");
        }
      })), React.createElement("div", {
        className: "column"
      }, React.createElement("a", {
        className: this.props.theme == "blue-theme" ? "active select-theme blue" : "select-theme blue",
        onClick: function onClick() {
          _this3.props.onChangeTheme("blue-theme");
        }
      })), React.createElement("div", {
        className: "column"
      }, React.createElement("a", {
        className: this.props.theme == "purple-theme" ? "active select-theme purple" : "select-theme purple",
        onClick: function onClick() {
          _this3.props.onChangeTheme("purple-theme");
        }
      })), React.createElement("div", {
        className: "column"
      }, React.createElement("a", {
        className: this.props.theme == "green-theme" ? "active select-theme green" : "select-theme green",
        onClick: function onClick() {
          _this3.props.onChangeTheme("green-theme");
        }
      }))))), React.createElement("div", {
        className: "row"
      }, React.createElement("div", {
        className: "column"
      }, React.createElement("label", null, "Intro"), React.createElement("p", null, "Optional text that goes at top of the home page of your directory. Only works when forking entire directory, otherwise use directory description (markdown supported)"), React.createElement("textarea", {
        value: this.props.introMarkdown,
        onChange: this.props.onIntroChange
      }))), React.createElement("div", {
        className: "row"
      }, React.createElement("div", {
        className: "column form-item"
      }, React.createElement("label", null, "FAQ"), React.createElement("p", null, "Optional text that goes on FAQ page (markdown supported)"), React.createElement("textarea", {
        value: this.props.faqMarkdown,
        onChange: this.props.onFAQChange
      }))), (!this.state.action || this.state.action == "forking") && React.createElement("div", {
        className: "row"
      }, React.createElement("div", {
        className: "column"
      }, React.createElement("p", null, React.createElement("i", {
        className: "fas fa-exclamation-triangle"
      }), " ", React.createElement("strong", null, "You are about to fork."), " This will upload a new version of this application to the Bitcoin (SV) blockchain."), React.createElement("p", null, "Please take a moment to double check the settings above are correct. The most important one is the admin address", React.createElement("br", null), React.createElement("mark", null, React.createElement("strong", null, this.state.admin_address))), React.createElement("p", null, "If you lose control of this address, you lose control of the directory."), React.createElement("p", null, React.createElement("strong", null, "Remember this action is forever tied to your Bitcoin address.")), React.createElement("input", _defineProperty({
        type: "submit",
        className: "button",
        value: "Add new link"
      }, "value", "Fork")))), this.state.action == "forking" && React.createElement("div", {
        className: "row"
      }, React.createElement("div", {
        className: "column"
      }, React.createElement("br", null), React.createElement("p", null, React.createElement("strong", null, "Forking ", this.props.title, "...")), React.createElement("p", null, "Swipe the button below to fork this directory."), React.createElement("div", null, React.createElement("div", {
        className: "fork-money-button"
      })))))), this.state.action == "post-fork" && React.createElement("div", {
        className: "row"
      }, React.createElement("div", {
        className: "column"
      }, React.createElement("p", null, React.createElement("strong", null, React.createElement("i", {
        className: "far fa-check-circle"
      }), " Successfully forked ", this.props.title, " to ")), React.createElement("p", null, React.createElement("strong", null, React.createElement("a", {
        className: "url",
        href: this.state.fork_address
      }, this.state.fork_address))), React.createElement("br", null), React.createElement("p", null, "Would you like to send a parting ping? This will help users find your directory\u2014you can pay to rank higher up the list."), React.createElement("div", null, React.createElement(TipchainItem, {
        item: selected_category,
        items: this.props.items,
        onSuccessHandler: this.handleSuccessfulTip.bind(this),
        onErrorHandler: this.props.onErrorHandler,
        custom_OP_RETURN: this.prepareOPReturnForPingback.bind(this)
      })))), this.state.action == "post-ping" && React.createElement("div", {
        className: "row"
      }, React.createElement("div", {
        className: "column"
      }, React.createElement("p", null, React.createElement("strong", null, React.createElement("i", {
        className: "far fa-check-circle"
      }), " Successfully pinged ", this.props.title)), React.createElement("p", null, "Please refresh to see your directory listed as a fork."), React.createElement("p", null, React.createElement("strong", null, "Visit your directory at ", React.createElement("a", {
        className: "url",
        href: this.state.fork_address
      }, this.state.fork_address))))));
    }
  }]);

  return Fork;
}(React.Component);

var AddTipchainAddressForm =
/*#__PURE__*/
function (_React$Component2) {
  _inherits(AddTipchainAddressForm, _React$Component2);

  function AddTipchainAddressForm(props) {
    var _this4;

    _classCallCheck(this, AddTipchainAddressForm);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(AddTipchainAddressForm).call(this, props));
    _this4.state = {
      "address": "",
      "name": ""
    };
    return _this4;
  }

  _createClass(AddTipchainAddressForm, [{
    key: "handleNameChange",
    value: function handleNameChange(e) {
      this.setState({
        "name": e.target.value
      });
    }
  }, {
    key: "handleAddressChange",
    value: function handleAddressChange(e) {
      this.setState({
        "address": e.target.value
      });
    }
  }, {
    key: "clearForm",
    value: function clearForm() {
      this.setState({
        "address": "",
        "name": ""
      });
    }
  }, {
    key: "handleSubmit",
    value: function handleSubmit() {
      this.props.onSubmit({
        "address": this.state.address,
        "type": "opendirectory",
        "name": this.state.name
      });
    }
  }, {
    key: "render",
    value: function render() {
      return React.createElement("fieldset", null, React.createElement("div", {
        className: "row"
      }, React.createElement("div", {
        className: "column"
      }, React.createElement("label", null, "Name:", React.createElement("input", {
        type: "text",
        value: this.state.name,
        onChange: this.handleNameChange.bind(this)
      }))), React.createElement("div", {
        className: "column"
      })), React.createElement("label", null, "Address:", React.createElement("input", {
        type: "text",
        value: this.state.address,
        onChange: this.handleAddressChange.bind(this)
      })), React.createElement("input", {
        type: "button",
        className: "button-outline",
        value: "Add tip address",
        onClick: this.handleSubmit.bind(this)
      }), "\xA0\xA0", React.createElement("a", {
        onClick: this.props.onCancel
      }, "cancel"));
    }
  }]);

  return AddTipchainAddressForm;
}(React.Component);

var ForkLog =
/*#__PURE__*/
function (_React$Component3) {
  _inherits(ForkLog, _React$Component3);

  function ForkLog() {
    _classCallCheck(this, ForkLog);

    return _possibleConstructorReturn(this, _getPrototypeOf(ForkLog).apply(this, arguments));
  }

  _createClass(ForkLog, [{
    key: "render",
    value: function render() {
      var timestamp = new Date().getTime();
      var forks = this.props.forks;

      if (!forks) {
        forks = [];
      }

      var slice = forks.slice(0, 10);

      if (forks && forks.length > 0) {
        return React.createElement("div", {
          className: "row"
        }, React.createElement("div", {
          className: "column"
        }, React.createElement("div", {
          id: "forklog"
        }, React.createElement("h3", null, React.createElement("i", {
          className: "fas fa-code-branch"
        }), " Forks"), React.createElement("table", null, React.createElement("tbody", null, slice.map(function (i) {
          var amount = satoshisToDollars(i.satoshis, BSV_PRICE);

          if (!amount) {
            amount = "$0.00";
          }

          var sats = i.satoshis > 0 ? i.satoshis + " sats" : "";
          return React.createElement("tr", {
            key: i.txid
          }, React.createElement("td", {
            className: "amount",
            title: sats
          }, amount), React.createElement("td", {
            className: "time"
          }, timeDifference(timestamp, i.time * 1000)), React.createElement("td", {
            className: "url"
          }, React.createElement("a", {
            href: getLink(i.fork_url)
          }, i.fork_url)));
        }))), React.createElement("br", null), React.createElement("hr", null))));
      } else {
        return null;
      }
    }
  }]);

  return ForkLog;
}(React.Component);
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var EntryItem =
/*#__PURE__*/
function (_Item) {
  _inherits(EntryItem, _Item);

  function EntryItem() {
    _classCallCheck(this, EntryItem);

    return _possibleConstructorReturn(this, _getPrototypeOf(EntryItem).apply(this, arguments));
  }

  _createClass(EntryItem, [{
    key: "render",
    value: function render() {
      var _this = this;

      var timestamp = new Date().getTime();
      var price = satoshisToDollars(this.props.item.satoshis, BSV_PRICE, true);
      var category = findObjectByTX(this.props.item.category, this.props.items);

      if (!category) {
        console.log("ITEMS", this.props.items);
        console.log(this.props.item);
        throw "NO CATEGORY";
      }

      var actions = React.createElement("span", {
        className: "actions"
      }, React.createElement("a", {
        onClick: this.handleToggleExpand.bind(this),
        className: "arrow",
        title: "txid " + this.props.item.txid
      }, this.state.isExpanded ? React.createElement("i", {
        className: "fas fa-caret-right"
      }) : React.createElement("i", {
        className: "fas fa-caret-down"
      })), this.state.isExpanded && React.createElement("a", {
        className: "action",
        onClick: this.handleEdit.bind(this)
      }, "edit"), this.state.isExpanded && React.createElement("a", {
        className: "action",
        onClick: this.handleDelete.bind(this)
      }, "delete"));
      return React.createElement("li", {
        id: this.props.item.txid,
        className: "entry"
      }, React.createElement("div", {
        className: "upvoteContainer"
      }, React.createElement("div", {
        className: "upvote"
      }, React.createElement("a", {
        onClick: this.handleUpvote.bind(this)
      }, React.createElement("i", {
        className: "fas fa-chevron-up"
      })), " ", React.createElement("span", {
        className: "number satoshis",
        title: this.props.item.satoshis + " sats"
      }, price), React.createElement("span", {
        className: "number votes",
        title: this.props.item.hottness.toFixed(2) + " hot score"
      }, pluralize(this.props.item.votes, "vote", "votes"))), React.createElement("div", {
        className: "entry"
      }, React.createElement("div", {
        className: "entry-wrapper"
      }, React.createElement("h5", null, React.createElement("a", {
        target: "_blank",
        href: getLink(this.props.item.link)
      }, this.props.item.name), " ", !this.props.item.height && React.createElement("span", {
        className: "pending"
      }, "pending"), "  ", this.props.showCategory && React.createElement("span", null, React.createElement("span", {
        className: "from-category-prefix"
      }, "in"), " ", React.createElement("a", {
        className: "from-category",
        onClick: function onClick() {
          _this.props.changeURL("/category/" + category.txid);
        }
      }, category.name)), " ", React.createElement("span", {
        className: "time"
      }, timeDifference(timestamp, this.props.item.time * 1000)), " ", actions), React.createElement("p", {
        className: "description"
      }, this.props.item.description), React.createElement("p", {
        className: "url"
      }, React.createElement("a", {
        target: "_blank",
        href: getLink(this.props.item.link)
      }, this.props.item.link)), this.state.action == "editing" && React.createElement("div", {
        className: "inline-edit"
      }, React.createElement(EditEntryForm, {
        item: this.props.item,
        onSuccessHandler: this.props.onSuccessHandler,
        onErrorHandler: this.props.onErrorHandler,
        onSubmit: this.clearForm.bind(this)
      })), this.state.action == "tipping" && React.createElement(TipchainItem, {
        item: this.props.item,
        items: this.props.items,
        onSuccessHandler: this.handleSuccessfulTip.bind(this),
        onErrorHandler: this.props.onErrorHandler
      }), this.state.action == "deleting" && React.createElement("div", {
        className: "inline-delete"
      }, React.createElement(DeleteItem, {
        item: this.props.item,
        onSuccessHandler: this.handleSuccessfulDelete.bind(this),
        onErrorHandler: this.props.onErrorHandler
      })))), React.createElement("div", {
        className: "clearfix"
      })));
    }
  }]);

  return EntryItem;
}(Item);

var AddEntryForm =
/*#__PURE__*/
function (_React$Component) {
  _inherits(AddEntryForm, _React$Component);

  _createClass(AddEntryForm, [{
    key: "render",
    value: function render() {
      return React.createElement("div", {
        className: "column"
      }, React.createElement("h3", null, React.createElement("i", {
        className: "fas fa-link"
      }), " Add new link to ", React.createElement("span", {
        className: "highlight"
      }, this.props.category.name)), React.createElement("p", null, "Submit a link and earn money when it gets upvoted. Keep it high-quality, remember this action is forever tied to your Bitcoin address."), React.createElement("form", {
        onSubmit: this.handleSubmit
      }, React.createElement("fieldset", null, React.createElement("div", {
        className: "row"
      }, React.createElement("div", {
        className: "column"
      }, React.createElement("label", null, "Title:", React.createElement("input", {
        type: "text",
        value: this.state.title,
        onChange: this.handleTitleChange
      }))), React.createElement("div", {
        className: "column"
      })), React.createElement("label", null, "Link:", React.createElement("input", {
        type: "text",
        value: this.state.link,
        onChange: this.handleLinkChange,
        placeholder: "bit://"
      })), React.createElement("label", null, "Description:", React.createElement("textarea", {
        onChange: this.handleDescriptionChange,
        value: this.state.description
      })), React.createElement("input", {
        type: "submit",
        className: "button-outline",
        value: "Add new link"
      }), React.createElement("div", null, React.createElement("div", {
        className: "add-entry-money-button"
      })))));
    }
  }, {
    key: "handleSubmit",
    value: function handleSubmit(e) {
      var _this3 = this;

      e.preventDefault();

      if (!this.validate()) {
        return;
      }

      var OP_RETURN = [OPENDIR_PROTOCOL, "entry.create", this.props.category.txid, "name", this.state.title, "link", this.state.link, "description", this.state.description];
      console.log(OP_RETURN);
      var el = document.querySelector(".add-entry-money-button");
      databutton.build({
        data: OP_RETURN,
        button: {
          $el: el,
          onPayment: function onPayment(msg) {
            console.log(msg);
            setTimeout(function () {
              _this3.clearForm();
            }, 5000);
            setTimeout(function () {
              _this3.setState({
                title: "",
                link: "",
                description: ""
              });

              _this3.props.onSuccessHandler("Successfully added new link, it will appear automatically—please refresh the page if it doesn't.");
            }, 3000);
          }
        }
      });
    }
  }]);

  function AddEntryForm(props) {
    var _this2;

    _classCallCheck(this, AddEntryForm);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(AddEntryForm).call(this, props));
    _this2.state = {
      title: "",
      link: "",
      description: ""
    };
    _this2._isMounted = false;
    _this2.handleTitleChange = _this2.handleTitleChange.bind(_assertThisInitialized(_this2));
    _this2.handleLinkChange = _this2.handleLinkChange.bind(_assertThisInitialized(_this2));
    _this2.handleDescriptionChange = _this2.handleDescriptionChange.bind(_assertThisInitialized(_this2));
    _this2.handleSubmit = _this2.handleSubmit.bind(_assertThisInitialized(_this2));
    return _this2;
  }

  _createClass(AddEntryForm, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      window.addEventListener('popstate', this.clearForm.bind(this), false);
      this._isMounted = true;
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener('popstate', this.clearForm.bind(this));
      this._isMounted = false;
    }
  }, {
    key: "clearForm",
    value: function clearForm() {
      if (this._isMounted) {
        var el = document.querySelector(".add-entry-money-button");

        if (el) {
          var parentNode = el.parentNode;
          parentNode.removeChild(el);
          var newEl = document.createElement('div');
          newEl.className = "add-entry-money-button";
          parentNode.appendChild(newEl);
        }

        this.setState({
          title: "",
          link: "",
          description: ""
        });
      }
    }
  }, {
    key: "validate",
    value: function validate() {
      if (!this.props.category) {
        alert("Invalid category");
        return false;
      }

      if (!this.state.title) {
        alert("Invalid title");
        return false;
      }

      if (!this.state.link) {
        alert("Invalid link");
        return false;
      }

      if (this.state.link.indexOf("://") == -1) {
        if (!confirm("The link doesn't look valid, are you sure you want to continue?")) {
          return false;
        }
      }

      if (!this.state.description) {
        alert("Invalid description");
        return false;
      }

      return true;
    }
  }, {
    key: "handleTitleChange",
    value: function handleTitleChange(e) {
      this.setState({
        title: e.target.value
      });
    }
  }, {
    key: "handleLinkChange",
    value: function handleLinkChange(e) {
      this.setState({
        link: e.target.value
      });
    }
  }, {
    key: "handleDescriptionChange",
    value: function handleDescriptionChange(e) {
      this.setState({
        description: e.target.value
      });
    }
  }]);

  return AddEntryForm;
}(React.Component);

var EditEntryForm =
/*#__PURE__*/
function (_React$Component2) {
  _inherits(EditEntryForm, _React$Component2);

  function EditEntryForm(props) {
    var _this4;

    _classCallCheck(this, EditEntryForm);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(EditEntryForm).call(this, props));
    _this4.state = {
      title: props.item.name,
      link: props.item.link,
      description: props.item.description,
      isShowingWarning: false
    };
    _this4._isMounted = false;
    _this4.handleTitleChange = _this4.handleTitleChange.bind(_assertThisInitialized(_this4));
    _this4.handleLinkChange = _this4.handleLinkChange.bind(_assertThisInitialized(_this4));
    _this4.handleDescriptionChange = _this4.handleDescriptionChange.bind(_assertThisInitialized(_this4));
    _this4.handleSubmit = _this4.handleSubmit.bind(_assertThisInitialized(_this4));
    return _this4;
  }

  _createClass(EditEntryForm, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      window.addEventListener('popstate', this.clearForm.bind(this), false);
      this._isMounted = true;
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener('popstate', this.clearForm.bind(this));
      this._isMounted = false;
    }
  }, {
    key: "clearForm",
    value: function clearForm() {
      if (this._isMounted) {
        var el = document.getElementById(this.props.item.txid).querySelector(".change-entry-money-button");

        if (el) {
          var parentNode = el.parentNode;
          parentNode.removeChild(el);
          var newEl = document.createElement('div');
          newEl.className = "change-entry-money-button";
          parentNode.appendChild(newEl);
        }

        this.setState({
          title: "",
          link: "",
          description: "",
          isShowingWarning: false
        });
      }
    }
  }, {
    key: "validate",
    value: function validate() {
      if (!this.state.title) {
        alert("Invalid title");
        return false;
      }

      if (!this.state.link) {
        alert("Invalid link");
        return false;
      }

      if (this.state.link.indexOf("://") == -1) {
        if (!confirm("The link doesn't look valid, are you sure you want to continue?")) {
          return false;
        }
      }

      if (!this.state.description) {
        alert("Invalid description");
        return false;
      }

      return true;
    }
  }, {
    key: "handleTitleChange",
    value: function handleTitleChange(e) {
      this.setState({
        title: e.target.value
      });
    }
  }, {
    key: "handleLinkChange",
    value: function handleLinkChange(e) {
      this.setState({
        link: e.target.value
      });
    }
  }, {
    key: "handleDescriptionChange",
    value: function handleDescriptionChange(e) {
      this.setState({
        description: e.target.value
      });
    }
  }, {
    key: "render",
    value: function render() {
      return React.createElement("div", {
        className: "column"
      }, React.createElement("h3", null, "Edit link ", React.createElement("span", {
        className: "highlight"
      }, this.props.item.name)), React.createElement("form", {
        onSubmit: this.handleSubmit
      }, React.createElement("fieldset", null, React.createElement("div", {
        className: "row"
      }, React.createElement("div", {
        className: "column"
      }, React.createElement("label", null, "Title:", React.createElement("input", {
        type: "text",
        value: this.state.title,
        onChange: this.handleTitleChange
      }))), React.createElement("div", {
        className: "column"
      })), React.createElement("label", null, "Link:", React.createElement("input", {
        type: "text",
        value: this.state.link,
        onChange: this.handleLinkChange,
        placeholder: "bit://"
      })), React.createElement("label", null, "Description:", React.createElement("textarea", {
        onChange: this.handleDescriptionChange,
        value: this.state.description
      })), React.createElement("input", {
        type: "submit",
        className: "button-outline",
        value: "Edit link"
      }), React.createElement("div", null, this.state.isShowingWarning && React.createElement("div", {
        className: "notice"
      }, React.createElement("span", {
        className: "warning"
      }, "You are editing this link, are you sure you want to do this?"), React.createElement("div", {
        className: "explain"
      }, React.createElement("p", null, "If you change this link you'll be permanently changing it in this directory for everyone else. Please only do this if you think it's in the best interest of the directory. Your Bitcoin key is forever tied to this transaction, so it will always be traced to you."), React.createElement("p", null, React.createElement("strong", null, "Permanently change this link?")), React.createElement("div", {
        className: "change-entry-money-button"
      }), " "))))));
    }
  }, {
    key: "handleSubmit",
    value: function handleSubmit(e) {
      var _this5 = this;

      e.preventDefault();

      if (!this.validate()) {
        return;
      }

      var OP_RETURN = [OPENDIR_PROTOCOL, "entry.update", this.props.item.txid];
      var edited = false;

      if (this.props.item.name != this.state.title) {
        OP_RETURN.push("name");
        OP_RETURN.push(this.state.title);
        edited = true;
      }

      if (this.props.item.link != this.state.link) {
        OP_RETURN.push("link");
        OP_RETURN.push(this.state.link);
        edited = true;
      }

      if (this.props.item.description != this.state.description) {
        OP_RETURN.push("description");
        OP_RETURN.push(this.state.description);
        edited = true;
      }

      if (!edited) {
        alert("Nothing was edited with the category, please try again");
        return;
      }

      console.log(OP_RETURN);
      this.setState({
        "isShowingWarning": true
      }, function () {
        var el = document.getElementById(_this5.props.item.txid).querySelector(".change-entry-money-button");
        databutton.build({
          data: OP_RETURN,
          button: {
            $el: el,
            onPayment: function onPayment(msg) {
              console.log(msg);
              setTimeout(function () {
                var name = _this5.state.title;
                var desc = _this5.state.description;
                var link = _this5.state.link;

                _this5.clearForm();

                _this5.setState({
                  title: name,
                  description: desc,
                  link: link
                });

                _this5.props.onSubmit();
              }, 5000);
              setTimeout(function () {
                _this5.setState({
                  title: "",
                  link: "",
                  description: ""
                });

                _this5.props.onSuccessHandler("Successfully edited new link, it will appear automatically—please refresh the page if it doesn't.");
              }, 3000);
            }
          }
        });
      });
    }
  }]);

  return EditEntryForm;
}(React.Component);
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var CategoryItem =
/*#__PURE__*/
function (_Item) {
  _inherits(CategoryItem, _Item);

  function CategoryItem() {
    _classCallCheck(this, CategoryItem);

    return _possibleConstructorReturn(this, _getPrototypeOf(CategoryItem).apply(this, arguments));
  }

  _createClass(CategoryItem, [{
    key: "render",
    value: function render() {
      var _this = this;

      var price = satoshisToDollars(this.props.item.satoshis, BSV_PRICE, true);
      return React.createElement("li", {
        id: this.props.item.txid,
        className: "category"
      }, React.createElement("div", {
        className: "upvoteContainer"
      }, React.createElement("div", {
        className: "upvote"
      }, React.createElement("a", {
        onClick: this.handleUpvote.bind(this)
      }, React.createElement("i", {
        className: "fas fa-chevron-up"
      }), "\xA0"), " ", React.createElement("span", {
        className: "number satoshis",
        title: this.props.item.satoshis + " sats"
      }, price), React.createElement("span", {
        className: "number votes",
        title: this.props.item.hottness + " hottness"
      }, pluralize(this.props.item.votes, "vote", "votes"))), React.createElement("div", {
        className: "category"
      }, React.createElement("h3", null, React.createElement("a", {
        onClick: function onClick() {
          _this.props.changeURL("/category/" + _this.props.item.txid);
        }
      }, this.props.item.name), !this.props.item.height && React.createElement("span", {
        className: "pending"
      }, "pending"), React.createElement("span", {
        className: "category-count"
      }, "(", this.props.item.entries, ")")), React.createElement(ReactMarkdown, {
        className: "description",
        source: this.props.item.description
      }), this.state.action == "tipping" && React.createElement(TipchainItem, {
        item: this.props.item,
        items: this.props.items,
        onSuccessHandler: this.handleSuccessfulTip.bind(this),
        onErrorHandler: this.props.onErrorHandler
      })), React.createElement("div", {
        className: "clearfix"
      })));
    }
  }]);

  return CategoryItem;
}(Item);

var AddCategoryForm =
/*#__PURE__*/
function (_React$Component) {
  _inherits(AddCategoryForm, _React$Component);

  function AddCategoryForm(props) {
    var _this2;

    _classCallCheck(this, AddCategoryForm);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(AddCategoryForm).call(this, props));
    _this2.state = {
      title: "",
      description: ""
    };
    _this2._isMounted = false;
    _this2.handleTitleChange = _this2.handleTitleChange.bind(_assertThisInitialized(_this2));
    _this2.handleLinkChange = _this2.handleLinkChange.bind(_assertThisInitialized(_this2));
    _this2.handleDescriptionChange = _this2.handleDescriptionChange.bind(_assertThisInitialized(_this2));
    _this2.handleSubmit = _this2.handleSubmit.bind(_assertThisInitialized(_this2));
    return _this2;
  }

  _createClass(AddCategoryForm, [{
    key: "render",
    value: function render() {
      var dirtype = this.props.category.txid ? "category" : "directory";
      var header;

      if (this.props.category.txid) {
        header = React.createElement("div", null, React.createElement("h3", null, React.createElement("i", {
          className: "fas fa-folder"
        }), " Add new subcategory under ", React.createElement("span", {
          className: "highlight"
        }, this.props.category.name)), React.createElement("p", null, "Submit a new subcategory to earn money when links get submitted and upvoted. Keep it high-quality, remember this action is forever tied to your Bitcoin address."));
      } else {
        header = React.createElement("div", null, React.createElement("h3", null, React.createElement("i", {
          className: "fas fa-folder"
        }), " Add new directory"), React.createElement("p", null, "Submit a new directory to earn money when links and categories get submitted and upvoted. Keep it high-quality, remember this action is forever tied to your Bitcoin address."));
      }

      return React.createElement("div", {
        className: "column",
        id: this.getCategoryID()
      }, header, React.createElement("form", {
        onSubmit: this.handleSubmit
      }, React.createElement("fieldset", null, React.createElement("div", {
        className: "row"
      }, React.createElement("div", {
        className: "column"
      }, React.createElement("label", null, "Title:", React.createElement("input", {
        type: "text",
        value: this.state.title,
        onChange: this.handleTitleChange
      }))), React.createElement("div", {
        className: "column"
      })), React.createElement("label", null, "Description:", React.createElement("textarea", {
        onChange: this.handleDescriptionChange,
        value: this.state.description
      })), React.createElement("input", {
        type: "submit",
        className: "button button-outline",
        value: this.props.category.txid ? "Add new subcategory" : "Add new directory"
      }), React.createElement("div", null, React.createElement("div", {
        className: "add-category-money-button"
      })))));
    }
  }, {
    key: "handleSubmit",
    value: function handleSubmit(e) {
      var _this3 = this;

      e.preventDefault();

      if (!this.validate()) {
        return;
      }

      var OP_RETURN = [OPENDIR_PROTOCOL, "category.create"];

      if (this.props.category.txid) {
        OP_RETURN.push(this.props.category.txid);
      }

      OP_RETURN.push("name");
      OP_RETURN.push(this.state.title);
      OP_RETURN.push("description");
      OP_RETURN.push(this.state.description);
      console.log(OP_RETURN);
      var el = document.querySelector(".add-category-money-button");
      databutton.build({
        data: OP_RETURN,
        button: {
          $el: el,
          onPayment: function onPayment(msg) {
            console.log(msg);
            setTimeout(function () {
              _this3.clearForm();
            }, 5000);
            setTimeout(function () {
              _this3.setState({
                title: "",
                description: ""
              });

              _this3.props.onSuccessHandler("Successfully added new category, it will appear automatically—please refresh the page if it doesn't.");
            }, 3000);
          }
        }
      });
    }
  }, {
    key: "getCategoryID",
    value: function getCategoryID() {
      return this.props.category.txid ? this.props.category.txid : "root-category";
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      window.addEventListener('popstate', this.clearForm.bind(this), false);
      this._isMounted = true;
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener('popstate', this.clearForm.bind(this));
      this._isMounted = false;
    }
  }, {
    key: "clearForm",
    value: function clearForm() {
      if (this._isMounted) {
        var el = document.querySelector(".add-category-money-button");

        if (el) {
          var parentNode = el.parentNode;
          parentNode.removeChild(el);
          var newEl = document.createElement('div');
          newEl.className = "add-category-money-button";
          parentNode.appendChild(newEl);
        }

        this.setState({
          title: "",
          description: ""
        });
      }
    }
  }, {
    key: "validate",
    value: function validate() {
      if (!this.state.title) {
        alert("Invalid title");
        return false;
      }

      if (!this.state.description) {
        alert("Invalid description");
        return false;
      }

      return true;
    }
  }, {
    key: "handleTitleChange",
    value: function handleTitleChange(e) {
      this.setState({
        title: e.target.value
      });
    }
  }, {
    key: "handleLinkChange",
    value: function handleLinkChange(e) {
      this.setState({
        link: e.target.value
      });
    }
  }, {
    key: "handleDescriptionChange",
    value: function handleDescriptionChange(e) {
      this.setState({
        description: e.target.value
      });
    }
  }]);

  return AddCategoryForm;
}(React.Component);

var EditCategoryForm =
/*#__PURE__*/
function (_React$Component2) {
  _inherits(EditCategoryForm, _React$Component2);

  function EditCategoryForm(props) {
    var _this4;

    _classCallCheck(this, EditCategoryForm);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(EditCategoryForm).call(this, props));
    _this4.state = {
      title: props.category.name,
      description: props.category.description,
      isShowingWarning: false
    };
    _this4._isMounted = false;
    _this4.handleTitleChange = _this4.handleTitleChange.bind(_assertThisInitialized(_this4));
    _this4.handleLinkChange = _this4.handleLinkChange.bind(_assertThisInitialized(_this4));
    _this4.handleDescriptionChange = _this4.handleDescriptionChange.bind(_assertThisInitialized(_this4));
    _this4.handleSubmit = _this4.handleSubmit.bind(_assertThisInitialized(_this4));
    return _this4;
  }

  _createClass(EditCategoryForm, [{
    key: "render",
    value: function render() {
      return React.createElement("div", {
        className: "column",
        id: this.getCategoryID()
      }, React.createElement("h3", null, "Edit ", React.createElement("span", {
        className: "highlight"
      }, this.props.category.name)), React.createElement("form", {
        onSubmit: this.handleSubmit
      }, React.createElement("fieldset", null, React.createElement("div", {
        className: "row"
      }, React.createElement("div", {
        className: "column"
      }, React.createElement("label", null, "Title:", React.createElement("input", {
        type: "text",
        value: this.state.title,
        onChange: this.handleTitleChange
      }))), React.createElement("div", {
        className: "column"
      })), React.createElement("label", null, "Description:", React.createElement("textarea", {
        onChange: this.handleDescriptionChange,
        value: this.state.description
      })), React.createElement("input", {
        type: "submit",
        className: "button button-outline",
        value: "Edit category"
      }), React.createElement("div", null, this.state.isShowingWarning && React.createElement("div", {
        className: "notice"
      }, React.createElement("span", {
        className: "warning"
      }, "You are editing this category, are you sure you want to do this?"), React.createElement("div", {
        className: "explain"
      }, React.createElement("p", null, "If you change this category you'll be permanently changing it in this directory for everyone else. Please only do this if you think it's in the best interest of the directory. Your Bitcoin key is forever tied to this transaction, so it will always be traced to you."), React.createElement("p", null, React.createElement("strong", null, "Permanently change this category?")), React.createElement("div", {
        className: "change-category-money-button"
      }), " "))))));
    }
  }, {
    key: "handleSubmit",
    value: function handleSubmit(e) {
      var _this5 = this;

      e.preventDefault();

      if (!this.validate()) {
        return;
      }

      if (!this.props.category.txid) {
        alert("An unknown error occured, category doesn't have a txid to edit");
        return;
      }

      var OP_RETURN = [OPENDIR_PROTOCOL, "category.update", this.props.category.txid];
      var edited = false;

      if (this.props.category.name != this.state.title) {
        OP_RETURN.push("name");
        OP_RETURN.push(this.state.title);
        edited = true;
      }

      if (this.props.category.description != this.state.description) {
        OP_RETURN.push("description");
        OP_RETURN.push(this.state.description);
        edited = true;
      }

      if (!edited) {
        alert("Nothing was edited with the category, please try again");
        return;
      }

      this.setState({
        "isShowingWarning": true
      }, function () {
        console.log(OP_RETURN);
        var el = document.getElementById(_this5.getCategoryID()).querySelector(".change-category-money-button");
        databutton.build({
          data: OP_RETURN,
          button: {
            $el: el,
            onPayment: function onPayment(msg) {
              console.log(msg);
              setTimeout(function () {
                var name = _this5.state.title;
                var desc = _this5.state.description;

                _this5.clearForm();

                _this5.setState({
                  title: name,
                  description: desc
                });

                _this5.props.onSubmit();
              }, 5000);
              setTimeout(function () {
                _this5.props.onSuccessHandler("Successfully edited category, it will appear automatically—please refresh the page if it doesn't.");
              }, 3000);
            }
          }
        });
      });
    }
  }, {
    key: "getCategoryID",
    value: function getCategoryID() {
      return this.props.category.txid ? this.props.category.txid : "root-category";
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      window.addEventListener('popstate', this.clearForm.bind(this), false);
      this._isMounted = true;
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener('popstate', this.clearForm.bind(this));
      this._isMounted = false;
    }
  }, {
    key: "clearForm",
    value: function clearForm() {
      if (this._isMounted) {
        var el = document.getElementById(this.getCategoryID()).querySelector(".change-category-money-button");

        if (el) {
          var parentNode = el.parentNode;
          parentNode.removeChild(el);
          var newEl = document.createElement('div');
          newEl.className = "change-category-money-button";
          parentNode.appendChild(newEl);
        }

        this.setState({
          title: "",
          description: "",
          isShowingWarning: false
        });
      }
    }
  }, {
    key: "validate",
    value: function validate() {
      if (!this.state.title) {
        alert("Invalid title");
        return false;
      }

      if (!this.state.description) {
        alert("Invalid description");
        return false;
      }

      return true;
    }
  }, {
    key: "handleTitleChange",
    value: function handleTitleChange(e) {
      this.setState({
        title: e.target.value
      });
    }
  }, {
    key: "handleLinkChange",
    value: function handleLinkChange(e) {
      this.setState({
        link: e.target.value
      });
    }
  }, {
    key: "handleDescriptionChange",
    value: function handleDescriptionChange(e) {
      this.setState({
        description: e.target.value
      });
    }
  }]);

  return EditCategoryForm;
}(React.Component);

var AddDirectoryPage =
/*#__PURE__*/
function (_React$Component3) {
  _inherits(AddDirectoryPage, _React$Component3);

  function AddDirectoryPage() {
    _classCallCheck(this, AddDirectoryPage);

    return _possibleConstructorReturn(this, _getPrototypeOf(AddDirectoryPage).apply(this, arguments));
  }

  _createClass(AddDirectoryPage, [{
    key: "render",
    value: function render() {
      return React.createElement("div", null, React.createElement("br", null), React.createElement(AddCategoryForm, {
        category: this.props.category,
        onSuccessHandler: this.props.onSuccessHandler,
        onErrorHandler: this.props.onErrorHandler
      }));
    }
  }]);

  return AddDirectoryPage;
}(React.Component);
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var BaseList =
/*#__PURE__*/
function (_React$Component) {
  _inherits(BaseList, _React$Component);

  function BaseList(props) {
    var _this;

    _classCallCheck(this, BaseList);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BaseList).call(this, props));
    _this.state = {
      "sort": "hot",
      "limit": props.limit || 10,
      "category_limit": 10,
      "cursor": 0,
      "action": null,
      "isExpanded": false
    };
    _this._isMounted = false;
    return _this;
  }

  _createClass(BaseList, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this._isMounted = true;
      window.addEventListener('popstate', this.clearForm.bind(this), false);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._isMounted = false;
      window.removeEventListener('popstate', this.clearForm.bind(this));
    }
  }, {
    key: "clearForm",
    value: function clearForm() {
      if (this._isMounted) {
        this.setState({
          "action": null,
          "isExpanded": false,
          "cursor": 0
        });
      }
    }
  }, {
    key: "findCategoryByTXID",
    value: function findCategoryByTXID(txid) {
      return this.props.items.filter(function (i) {
        return i.type == "category" && i.txid == txid;
      }).shift();
    }
  }, {
    key: "handleChangeSortOrder",
    value: function handleChangeSortOrder(order) {
      if (order == "time") {
        this.setState({
          "sort": "time",
          "cursor": 0
        });
      } else if (order == "votes") {
        this.setState({
          "sort": "votes",
          "cursor": 0
        });
      } else if (order == "money") {
        this.setState({
          "sort": "money",
          "cursor": 0
        });
      } else if (order == "submissions") {
        this.setState({
          "sort": "submissions",
          "cursor": 0
        });
      } else {
        this.setState({
          "sort": "hot",
          "cursor": 0
        });
      }
    }
  }, {
    key: "handlePageChange",
    value: function handlePageChange(page) {
      var idx = page - 1;
      var cursor = idx * this.state.limit;
      this.setState({
        "cursor": cursor
      });
      this.scrollToTop();
    }
  }, {
    key: "handleSuccessfulTip",
    value: function handleSuccessfulTip() {
      this.setState({
        "action": null
      });
      this.props.onSuccessHandler("Successfully upvoted " + this.props.category.type + ", it will appear automatically—please refresh the page if it doesn't");
    }
  }, {
    key: "handleShowAllCategories",
    value: function handleShowAllCategories() {
      this.setState({
        "category_limit": -1
      });
    }
  }, {
    key: "handleSuccessfulDelete",
    value: function handleSuccessfulDelete() {
      this.setState({
        "action": null
      });
      this.props.onSuccessHandler("Successfully deleted " + this.props.category.type + ", it will appear automatically—please refresh the page if it doesn't");
    }
  }, {
    key: "handleUpvote",
    value: function handleUpvote(e) {
      this.setState({
        "action": "tipping"
      });
    }
  }, {
    key: "handleToggleExpand",
    value: function handleToggleExpand(e) {
      this.setState({
        "isExpanded": !this.state.isExpanded,
        "action": null
      });
    }
  }, {
    key: "handleEdit",
    value: function handleEdit(e) {
      this.setState({
        "action": "editing"
      });
    }
  }, {
    key: "handleDelete",
    value: function handleDelete(e) {
      this.setState({
        "action": "deleting"
      });
    }
  }, {
    key: "getUnsortedCategories",
    value: function getUnsortedCategories() {
      var category_id = this.props.category ? this.props.category.txid : get_root_category_txid();
      return this.props.items.filter(function (i) {
        return !i.deleted && i.type == "category" && i.category == category_id;
      });
    }
  }, {
    key: "getUnsortedEntries",
    value: function getUnsortedEntries() {
      return this.props.items.filter(function (i) {
        return !i.deleted && i.type == "entry";
      });
    }
  }, {
    key: "sortCompare",
    value: function sortCompare(a, b) {
      if (this.state.sort == "time") {
        if (!a.height) {
          return -1;
        }

        if (a.height < b.height) {
          return 1;
        }

        if (a.height > b.height) {
          return -1;
        }
      } else if (this.state.sort == "votes") {
        if (a.votes < b.votes) {
          return 1;
        }

        if (a.votes > b.votes) {
          return -1;
        }

        if (a.height < b.height) {
          return 1;
        }

        if (a.height > b.height) {
          return -1;
        }
      } else if (this.state.sort == "money") {
        if (a.satoshis < b.satoshis) {
          return 1;
        }

        if (a.satoshis > b.satoshis) {
          return -1;
        }

        if (a.votes < b.votes) {
          return 1;
        }

        if (a.votes > b.votes) {
          return -1;
        }

        if (a.height < b.height) {
          return 1;
        }

        if (a.height > b.height) {
          return -1;
        }
      } else if (this.state.sort == "submissions") {
        if (a.entries < b.entries) {
          return 1;
        }

        if (a.entries > b.entries) {
          return -1;
        }

        if (a.satoshis < b.satoshis) {
          return 1;
        }

        if (a.satoshis > b.satoshis) {
          return -1;
        }

        if (a.votes < b.votes) {
          return 1;
        }

        if (a.votes > b.votes) {
          return -1;
        }

        if (a.height < b.height) {
          return 1;
        }

        if (a.height > b.height) {
          return -1;
        }
      } else {
        // hot
        if (a.hottness < b.hottness) {
          return 1;
        }

        if (a.hottness > b.hottness) {
          return -1;
        }

        if (a.satoshis < b.satoshis) {
          return 1;
        }

        if (a.satoshis > b.satoshis) {
          return -1;
        }

        if (a.votes < b.votes) {
          return 1;
        }

        if (a.votes > b.votes) {
          return -1;
        }

        if (a.height < b.height) {
          return 1;
        }

        if (a.height > b.height) {
          return -1;
        }
      }

      return 0;
    }
  }, {
    key: "getCategories",
    value: function getCategories() {
      var _this2 = this;

      return this.getUnsortedCategories().sort(function (a, b) {
        return _this2.sortCompare(a, b);
      });
    }
  }, {
    key: "getEntries",
    value: function getEntries() {
      var _this3 = this;

      if (this.props.category) {
        var entries = this.props.items.filter(function (i) {
          return !i.deleted && i.type == "entry" && i.category && i.category == _this3.props.category.txid;
        });
        return entries.sort(function (a, b) {
          return _this3.sortCompare(a, b);
        });
      }

      return [];
    }
  }]);

  return BaseList;
}(React.Component);

var SubcategoryList =
/*#__PURE__*/
function (_BaseList) {
  _inherits(SubcategoryList, _BaseList);

  function SubcategoryList() {
    _classCallCheck(this, SubcategoryList);

    return _possibleConstructorReturn(this, _getPrototypeOf(SubcategoryList).apply(this, arguments));
  }

  _createClass(SubcategoryList, [{
    key: "handleClickShowAllSubcategories",
    value: function handleClickShowAllSubcategories() {
      this.setState({
        "category_limit": -1
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var categories = this.getCategories();
      var top_categories;

      if (this.state.category_limit == -1) {
        top_categories = categories;
      } else {
        top_categories = categories.slice(0, this.state.category_limit);
      }

      var entries = this.getEntries();
      var price = satoshisToDollars(this.props.category.satoshis, BSV_PRICE, true);
      var slice = entries.slice(this.state.cursor, this.state.cursor + this.state.limit);
      var numPages = Math.ceil(entries.length / this.state.limit);

      var pages = _toConsumableArray(Array(numPages).keys()).map(function (idx) {
        var page = idx + 1;
        return React.createElement("a", {
          key: "page-" + page,
          className: _this4.state.cursor == idx * _this4.state.limit ? "active" : null,
          onClick: function onClick() {
            _this4.handlePageChange(page);
          }
        }, page);
      });

      var actions = React.createElement("span", {
        className: "actions"
      }, React.createElement("a", {
        onClick: this.handleToggleExpand.bind(this),
        className: "arrow",
        title: "txid " + this.props.category.txid
      }, this.state.isExpanded ? React.createElement("i", {
        "class": "fas fa-caret-right"
      }) : React.createElement("i", {
        className: "fas fa-caret-down"
      })), this.state.isExpanded && React.createElement("a", {
        className: "action",
        onClick: this.handleEdit.bind(this)
      }, "edit"), this.state.isExpanded && React.createElement("a", {
        className: "action",
        onClick: this.handleDelete.bind(this)
      }, "delete"));
      var parent;

      if (this.props.category && this.props.category.category) {
        parent = this.findCategoryByTXID(this.props.category.category);
      }

      var back;
      var heading;

      if (this.props.category) {
        if (parent) {
          var root_category_txid = get_root_category_txid();

          if (root_category_txid == null || this.props.category.txid !== root_category_txid) {
            var parent_url = "/category/" + parent.txid;

            if (parent.txid == root_category_txid) {
              parent_url = "/";
            }

            back = React.createElement("div", {
              className: "back"
            }, React.createElement("a", {
              onClick: function onClick() {
                _this4.props.changeURL(parent_url);
              }
            }, React.createElement("i", {
              className: "fas fa-long-arrow-alt-left"
            }), " ", parent.name), React.createElement("hr", null));
          }
        }

        if (this.props.category.name) {
          heading = React.createElement("div", {
            className: "category-meta",
            id: this.props.category.txid
          }, back, React.createElement("div", {
            className: "upvoteContainer"
          }, React.createElement("div", {
            className: "upvote"
          }, React.createElement("a", {
            onClick: this.handleUpvote.bind(this)
          }, React.createElement("i", {
            className: "fas fa-chevron-up"
          })), " ", React.createElement("span", {
            className: "number satoshis",
            title: this.props.category.satoshis + " sats"
          }, price), React.createElement("span", {
            className: "number votes",
            title: this.props.category.hottness + " hottness"
          }, pluralize(this.props.category.votes, "vote", "votes"))), React.createElement("div", null, React.createElement("h1", null, this.props.category.name, actions), this.state.action && React.createElement("div", {
            className: "category-container"
          }, this.state.action == "editing" && React.createElement("div", {
            className: "column"
          }, React.createElement(EditCategoryForm, {
            category: this.props.category,
            onSuccessHandler: this.props.onSuccessHandler,
            onErrorHandler: this.props.onErrorHandler,
            onSubmit: this.clearForm.bind(this)
          })), this.state.action == "tipping" && React.createElement(TipchainItem, {
            item: this.props.category,
            items: this.props.items,
            onSuccessHandler: this.handleSuccessfulTip.bind(this),
            onErrorHandler: this.props.onErrorHandler
          }), this.state.action == "deleting" && React.createElement(DeleteItem, {
            item: this.props.category,
            onSuccessHandler: this.handleSuccessfulDelete.bind(this),
            onErrorHandler: this.props.onErrorHandler
          })), React.createElement("div", {
            className: "markdown"
          }, React.createElement(ReactMarkdown, {
            source: this.props.category.description
          }))), React.createElement("div", {
            className: "clearfix"
          })));
        }
      }

      var entryListing;

      if (this.props.category.address && slice.length > 0) {
        entryListing = React.createElement("div", null, React.createElement("div", {
          id: "valid-links-exist"
        }), React.createElement("div", {
          className: "controls"
        }, React.createElement("div", {
          className: "sort"
        }, React.createElement("span", {
          className: "label"
        }, "sort by"), React.createElement("ul", null, React.createElement("li", null, React.createElement("i", {
          "class": "fab fa-hotjar"
        }), " ", React.createElement("a", {
          onClick: function onClick() {
            _this4.handleChangeSortOrder("hot");
          },
          className: this.state.sort == "hot" ? "active" : ""
        }, "hot")), React.createElement("li", null, React.createElement("i", {
          "class": "fas fa-dollar-sign"
        }), " ", React.createElement("a", {
          onClick: function onClick() {
            _this4.handleChangeSortOrder("money");
          },
          className: this.state.sort == "money" ? "active" : ""
        }, "money")), React.createElement("li", null, React.createElement("i", {
          "class": "fas fa-poll"
        }), " ", React.createElement("a", {
          onClick: function onClick() {
            _this4.handleChangeSortOrder("votes");
          },
          className: this.state.sort == "votes" ? "active" : ""
        }, "votes")), React.createElement("li", null, React.createElement("i", {
          "class": "fas fa-plus"
        }), " ", React.createElement("a", {
          onClick: function onClick() {
            _this4.handleChangeSortOrder("time");
          },
          className: this.state.sort == "time" ? "active" : ""
        }, "new"))), React.createElement("div", {
          className: "clearfix"
        }))), React.createElement("ul", {
          className: "entry list"
        }, slice.map(function (entry) {
          return React.createElement(EntryItem, {
            key: "entry-" + entry.txid,
            item: entry,
            items: _this4.props.items,
            onSuccessHandler: _this4.props.onSuccessHandler,
            onErrorHandler: _this4.props.onErrorHandler,
            changeURL: _this4.changeURL
          });
        })), pages.length > 1 && React.createElement("div", {
          className: "pages"
        }, pages));
      } else {
        if (!this.props.isError && !this.props.isLoading && this.props.category && this.props.category.txid) {
          entryListing = React.createElement("div", {
            className: "empty-entry-listing"
          }, React.createElement("p", null, React.createElement("i", {
            className: "fas fa-link"
          })), React.createElement("p", null, "There's no links here yet\u2014you should submit one! If you submit a good one and it gets upvoted, you'll get paid Bitcoin (SV)! \uD83D\uDC4D"));
        }
      }

      return React.createElement("div", null, this.props.category.deleted && React.createElement("div", {
        className: "deleted"
      }, "This category is deleted"), heading, categories && categories.length > 0 && React.createElement("div", {
        className: "category-wrapper"
      }, React.createElement("ul", {
        className: "category list"
      }, top_categories.map(function (category, i) {
        var output = React.createElement(CategoryItem, {
          key: "category-" + category.txid,
          item: category,
          items: _this4.props.items,
          onSuccessHandler: _this4.props.onSuccessHandler,
          onErrorHandler: _this4.props.onErrorHandler,
          changeURL: _this4.props.changeURL
        });

        if ((i + 1) % 3 == 0) {
          return [output, React.createElement("div", {
            key: "category-clearfix-" + i,
            className: "clearfix three-column"
          })];
        } else if ((i + 1) % 2 == 0) {
          return [output, React.createElement("div", {
            key: "category-clearfix-" + i,
            className: "clearfix two-column"
          })];
        } else {
          return output;
        }
      }), React.createElement("div", {
        className: "clearfix"
      })), React.createElement("div", {
        className: "clearfix"
      }), categories.length > top_categories.length && React.createElement("div", {
        className: "show-all-subcategories"
      }, React.createElement("i", {
        "class": "fas fa-chevron-circle-down"
      }), " ", React.createElement("a", {
        onClick: this.handleShowAllCategories.bind(this)
      }, "Show all ", categories.length, " subcategories"))), entryListing, React.createElement("div", {
        className: "clearfix"
      }));
    }
  }]);

  return SubcategoryList;
}(BaseList);

var HomepageEntries =
/*#__PURE__*/
function (_BaseList2) {
  _inherits(HomepageEntries, _BaseList2);

  function HomepageEntries() {
    _classCallCheck(this, HomepageEntries);

    return _possibleConstructorReturn(this, _getPrototypeOf(HomepageEntries).apply(this, arguments));
  }

  _createClass(HomepageEntries, [{
    key: "handleChangeEntryLimit",
    value: function handleChangeEntryLimit(num) {
      this.setState({
        "limit": num,
        "cursor": 0
      });
    }
  }, {
    key: "getHomepageEntries",
    value: function getHomepageEntries() {
      var _this5 = this;

      var entries = this.props.items.filter(function (i) {
        return !i.deleted && i.type == "entry";
      });
      return entries.sort(function (a, b) {
        return _this5.sortCompare(a, b);
      });
    }
  }, {
    key: "setCursorWithBoundsCheck",
    value: function setCursorWithBoundsCheck(cursor) {
      var entries = this.getTopHomepageEntries();
      var numPages = Math.ceil(entries.length / this.state.limit);
      var max_cursor = (numPages - 1) * this.state.limit;

      if (cursor < 0) {
        cursor = 0;
      } else if (cursor > max_cursor) {
        cursor = max_cursor;
      }

      this.setState({
        "cursor": cursor
      });
    }
  }, {
    key: "scrollToTop",
    value: function scrollToTop() {
      var top = document.querySelector(".homepage.entries .top");

      if (top) {
        top.scrollIntoView(true);
      }
    }
  }, {
    key: "handleNextPageChange",
    value: function handleNextPageChange() {
      this.setCursorWithBoundsCheck(this.state.cursor + this.state.limit);
      this.scrollToTop();
    }
  }, {
    key: "handlePreviousPageChange",
    value: function handlePreviousPageChange() {
      this.setCursorWithBoundsCheck(this.state.cursor - this.state.limit);
      this.scrollToTop();
    }
  }, {
    key: "getTopHomepageEntries",
    value: function getTopHomepageEntries() {
      var max_entries_on_homepage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 88;
      return this.getHomepageEntries().slice(0, max_entries_on_homepage);
    }
  }, {
    key: "render",
    value: function render() {
      var _this6 = this;

      var entries = this.getTopHomepageEntries();
      var slice = entries.slice(this.state.cursor, this.state.cursor + this.state.limit);
      var numPages = Math.ceil(entries.length / this.state.limit);

      var pages = _toConsumableArray(Array(numPages).keys()).map(function (idx) {
        var page = idx + 1;
        return React.createElement("a", {
          key: "page-" + page,
          className: _this6.state.cursor == idx * _this6.state.limit ? "active" : null,
          onClick: function onClick() {
            _this6.handlePageChange(page);
          }
        }, page);
      });

      var num_control = React.createElement("div", {
        className: "num_per_page"
      }, React.createElement("span", {
        className: "label"
      }, "per page"), React.createElement("ul", null, React.createElement("li", null, React.createElement("a", {
        onClick: function onClick() {
          _this6.handleChangeEntryLimit(15);
        },
        className: this.state.limit == 15 ? "active" : ""
      }, "15")), React.createElement("li", null, React.createElement("a", {
        onClick: function onClick() {
          _this6.handleChangeEntryLimit(25);
        },
        className: this.state.limit == 25 ? "active" : ""
      }, "25")), React.createElement("li", null, React.createElement("a", {
        onClick: function onClick() {
          _this6.handleChangeEntryLimit(50);
        },
        className: this.state.limit == 50 ? "active" : ""
      }, "50"))), React.createElement("div", {
        className: "clearfix"
      }));

      if (this.state.cursor > 0) {
        pages.unshift(React.createElement("a", {
          key: "page-previous",
          onClick: function onClick() {
            _this6.handlePreviousPageChange();
          }
        }, React.createElement("i", {
          className: "fas fa-angle-double-left"
        })));
      } else {
        pages.unshift(React.createElement("a", {
          className: "disabled",
          key: "page-previous"
        }, React.createElement("i", {
          className: "fas fa-angle-double-left"
        })));
      }

      var max_cursor = (numPages - 1) * this.state.limit;

      if (this.state.cursor < max_cursor) {
        pages.push(React.createElement("a", {
          key: "page-next",
          onClick: function onClick() {
            _this6.handleNextPageChange();
          }
        }, React.createElement("i", {
          className: "fas fa-angle-double-right"
        })));
      } else {
        pages.push(React.createElement("a", {
          className: "disabled",
          key: "page-next"
        }, React.createElement("i", {
          className: "fas fa-angle-double-right"
        })));
      }

      if (entries.length > 0) {
        return React.createElement("div", {
          className: "homepage entries"
        }, React.createElement("div", {
          className: "top"
        }), React.createElement("h3", null, "Trending Links"), React.createElement("div", {
          className: "controls"
        }, React.createElement("div", {
          className: "sort"
        }, React.createElement("span", {
          className: "sort-wrapper"
        }, React.createElement("span", {
          className: "label"
        }, "sort by"), React.createElement("ul", null, React.createElement("li", null, React.createElement("i", {
          "class": "fab fa-hotjar"
        }), " ", React.createElement("a", {
          onClick: function onClick() {
            _this6.handleChangeSortOrder("hot");
          },
          className: this.state.sort == "hot" ? "active" : ""
        }, "hot")), React.createElement("li", null, React.createElement("i", {
          "class": "fas fa-dollar-sign"
        }), " ", React.createElement("a", {
          onClick: function onClick() {
            _this6.handleChangeSortOrder("money");
          },
          className: this.state.sort == "money" ? "active" : ""
        }, "money")), React.createElement("li", null, React.createElement("i", {
          "class": "fas fa-poll"
        }), " ", React.createElement("a", {
          onClick: function onClick() {
            _this6.handleChangeSortOrder("votes");
          },
          className: this.state.sort == "votes" ? "active" : ""
        }, "votes")), React.createElement("li", null, React.createElement("i", {
          "class": "fas fa-plus"
        }), " ", React.createElement("a", {
          onClick: function onClick() {
            _this6.handleChangeSortOrder("time");
          },
          className: this.state.sort == "time" ? "active" : ""
        }, "new"))))), num_control, React.createElement("div", {
          className: "clearfix"
        })), React.createElement("ul", {
          className: "entry list"
        }, slice.map(function (entry) {
          return React.createElement(EntryItem, {
            key: "entry-" + entry.txid,
            item: entry,
            items: _this6.props.items,
            onSuccessHandler: _this6.props.onSuccessHandler,
            onErrorHandler: _this6.props.onErrorHandler,
            showCategory: true,
            changeURL: _this6.props.changeURL
          });
        })), pages.length > 1 && React.createElement("div", {
          className: "pages"
        }, pages), React.createElement("hr", null));
      } else {
        return null;
      }
    }
  }]);

  return HomepageEntries;
}(BaseList);

var HomepageList =
/*#__PURE__*/
function (_BaseList3) {
  _inherits(HomepageList, _BaseList3);

  function HomepageList() {
    _classCallCheck(this, HomepageList);

    return _possibleConstructorReturn(this, _getPrototypeOf(HomepageList).apply(this, arguments));
  }

  _createClass(HomepageList, [{
    key: "scrollToTop",
    value: function scrollToTop() {
      var top = document.querySelector(".homepage-categories .top");

      if (top) {
        top.scrollIntoView(true);
      }
    }
  }, {
    key: "handlePageChange",
    value: function handlePageChange(page) {
      var idx = page - 1;
      var cursor = idx * this.state.category_limit;
      this.setState({
        "cursor": cursor
      });
      this.scrollToTop();
    }
  }, {
    key: "setCursorWithBoundsCheck",
    value: function setCursorWithBoundsCheck(cursor) {
      var categories = this.getUnsortedCategories();
      var numPages = Math.ceil(categories.length / this.state.category_limit);
      var max_cursor = (numPages - 1) * this.state.category_limit;

      if (cursor < 0) {
        cursor = 0;
      } else if (cursor > max_cursor) {
        cursor = max_cursor;
      }

      this.setState({
        "cursor": cursor
      });
    }
  }, {
    key: "handleNextPageChange",
    value: function handleNextPageChange() {
      this.setCursorWithBoundsCheck(this.state.cursor + this.state.category_limit);
      this.scrollToTop();
    }
  }, {
    key: "handlePreviousPageChange",
    value: function handlePreviousPageChange() {
      this.setCursorWithBoundsCheck(this.state.cursor - this.state.category_limit);
      this.scrollToTop();
    }
  }, {
    key: "handleChangeCategoryLimit",
    value: function handleChangeCategoryLimit(num) {
      this.setState({
        "category_limit": num,
        "cursor": 0
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this7 = this;

      var categories = this.getCategories();
      var price = satoshisToDollars(this.props.category.satoshis, BSV_PRICE, true);
      var slice = categories.slice(this.state.cursor, this.state.cursor + this.state.category_limit);
      var numPages = Math.ceil(categories.length / this.state.category_limit);

      var pages = _toConsumableArray(Array(numPages).keys()).map(function (idx) {
        var page = idx + 1;
        return React.createElement("a", {
          key: "page-" + page,
          className: _this7.state.cursor == idx * _this7.state.category_limit ? "active" : null,
          onClick: function onClick() {
            _this7.handlePageChange(page);
          }
        }, page);
      });

      if (this.state.cursor > 0) {
        pages.unshift(React.createElement("a", {
          key: "page-previous",
          onClick: function onClick() {
            _this7.handlePreviousPageChange();
          }
        }, React.createElement("i", {
          className: "fas fa-angle-double-left"
        })));
      } else {
        pages.unshift(React.createElement("a", {
          className: "disabled",
          key: "page-previous"
        }, React.createElement("i", {
          className: "fas fa-angle-double-left"
        })));
      }

      var max_cursor = (numPages - 1) * this.state.category_limit;

      if (this.state.cursor < max_cursor) {
        pages.push(React.createElement("a", {
          key: "page-next",
          onClick: function onClick() {
            _this7.handleNextPageChange();
          }
        }, React.createElement("i", {
          className: "fas fa-angle-double-right"
        })));
      } else {
        pages.push(React.createElement("a", {
          className: "disabled",
          key: "page-next"
        }, React.createElement("i", {
          className: "fas fa-angle-double-right"
        })));
      }

      var actions = React.createElement("span", {
        className: "actions"
      }, React.createElement("a", {
        onClick: this.handleToggleExpand.bind(this),
        className: "arrow",
        title: "txid " + this.props.category.txid
      }, this.state.isExpanded ? React.createElement("i", {
        "class": "fas fa-caret-right"
      }) : React.createElement("i", {
        className: "fas fa-caret-down"
      })), this.state.isExpanded && React.createElement("a", {
        className: "action",
        onClick: this.handleEdit.bind(this)
      }, "edit"), this.state.isExpanded && React.createElement("a", {
        className: "action",
        onClick: this.handleDelete.bind(this)
      }, "delete"));
      var parent;

      if (this.props.category && this.props.category.category) {
        parent = this.findCategoryByTXID(this.props.category.category);
      }

      var back;

      if (this.props.category) {
        if (parent) {
          var root_category_txid = get_root_category_txid();

          if (root_category_txid == null || this.props.category.txid !== root_category_txid) {
            var parent_url = "/#" + parent.txid;

            if (parent.txid == root_category_txid) {
              parent_url = "/#";
            }

            back = React.createElement("div", {
              className: "back"
            }, React.createElement("a", {
              href: parent_url
            }, React.createElement("i", {
              className: "fas fa-long-arrow-alt-left"
            }), " ", parent.name), React.createElement("hr", null));
          }
        }
      }

      var sort_control = React.createElement("div", {
        className: "sort-control"
      }, React.createElement("div", {
        className: "sort"
      }, React.createElement("span", {
        className: "label"
      }, "sort by"), React.createElement("ul", null, React.createElement("li", null, React.createElement("i", {
        className: "fab fa-hotjar"
      }), " ", React.createElement("a", {
        onClick: function onClick() {
          _this7.handleChangeSortOrder("hot");
        },
        className: this.state.sort == "hot" ? "active" : ""
      }, "hot")), React.createElement("li", null, React.createElement("i", {
        className: "fas fa-dollar-sign"
      }), " ", React.createElement("a", {
        onClick: function onClick() {
          _this7.handleChangeSortOrder("money");
        },
        className: this.state.sort == "money" ? "active" : ""
      }, "money")), React.createElement("li", null, React.createElement("i", {
        "class": "fas fa-poll"
      }), " ", React.createElement("a", {
        onClick: function onClick() {
          _this7.handleChangeSortOrder("votes");
        },
        className: this.state.sort == "votes" ? "active" : ""
      }, "votes")), React.createElement("li", null, React.createElement("i", {
        "class": "fas fa-link"
      }), " ", React.createElement("a", {
        onClick: function onClick() {
          _this7.handleChangeSortOrder("submissions");
        },
        className: this.state.sort == "submisions" ? "active" : ""
      }, "links")), React.createElement("li", null, React.createElement("i", {
        "class": "fas fa-plus"
      }), " ", React.createElement("a", {
        onClick: function onClick() {
          _this7.handleChangeSortOrder("time");
        },
        className: this.state.sort == "time" ? "active" : ""
      }, "new"))), React.createElement("div", {
        className: "clearfix"
      })));
      var num_control = React.createElement("div", {
        className: "num_per_page"
      }, React.createElement("span", {
        className: "label"
      }, "per page"), React.createElement("ul", null, React.createElement("li", null, React.createElement("a", {
        onClick: function onClick() {
          _this7.handleChangeCategoryLimit(15);
        },
        className: this.state.category_limit == 15 ? "active" : ""
      }, "15")), React.createElement("li", null, React.createElement("a", {
        onClick: function onClick() {
          _this7.handleChangeCategoryLimit(25);
        },
        className: this.state.category_limit == 25 ? "active" : ""
      }, "25")), React.createElement("li", null, React.createElement("a", {
        onClick: function onClick() {
          _this7.handleChangeCategoryLimit(50);
        },
        className: this.state.category_limit == 50 ? "active" : ""
      }, "50"))), React.createElement("div", {
        className: "clearfix"
      }));
      return React.createElement("div", null, categories && categories.length > 0 && React.createElement("div", {
        className: "homepage-categories"
      }, React.createElement("div", {
        className: "top"
      }), React.createElement("h3", null, "Open Directories"), React.createElement("div", {
        className: "controls"
      }, sort_control, num_control, React.createElement("div", {
        className: "clearfix"
      })), React.createElement("ul", {
        className: "category list"
      }, slice.map(function (category, i) {
        var output = React.createElement(CategoryItem, {
          key: "category-" + category.txid,
          item: category,
          items: _this7.props.items,
          onSuccessHandler: _this7.props.onSuccessHandler,
          onErrorHandler: _this7.props.onErrorHandler,
          changeURL: _this7.props.changeURL
        });
        return output;
      }), React.createElement("div", {
        className: "clearfix"
      })), pages.length > 1 && React.createElement("div", {
        className: "pages"
      }, pages), React.createElement("div", {
        className: "clearfix"
      })), React.createElement("div", {
        className: "clearfix"
      }));
    }
  }]);

  return HomepageList;
}(BaseList);
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ChangeLog =
/*#__PURE__*/
function (_React$Component) {
  _inherits(ChangeLog, _React$Component);

  function ChangeLog(props) {
    var _this;

    _classCallCheck(this, ChangeLog);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ChangeLog).call(this, props));
    _this.state = {
      "isExpanded": false,
      "isShowAll": false
    };
    return _this;
  }

  _createClass(ChangeLog, [{
    key: "handleToggleExpand",
    value: function handleToggleExpand(e) {
      this.setState({
        "isExpanded": !this.state.isExpanded
      });
    }
  }, {
    key: "handleToggleShowAll",
    value: function handleToggleShowAll(e) {
      this.setState({
        "isShowAll": !this.state.isShowAll
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var idx = 0;
      var max = 5; // For now only show open directory protocol changes in changelog—in future may want to
      // pull in related bitcoin media

      var changelog = (this.props.changelog ? this.props.changelog.slice(0).reverse() : []).filter(function (i) {
        return i.data.s1 == OPENDIR_PROTOCOL || i.data.s1 == SETTINGS.admin_address;
      });
      return changelog && changelog.length > 0 && React.createElement("div", {
        className: "row"
      }, React.createElement("div", {
        className: "column"
      }, React.createElement("div", {
        id: "changelog"
      }, React.createElement("h3", null, React.createElement("i", {
        className: "fas fa-history"
      }), " Changelog"), React.createElement("table", null, React.createElement("tbody", null, changelog.map(function (i) {
        if (idx++ <= max || _this2.state.isShowAll) {
          return React.createElement(ChangeLogItem, {
            item: i,
            txpool: _this2.props.txpool,
            key: "changelog-" + i.txid,
            onSuccessHandler: _this2.props.onSuccessHandler,
            onErrorHandler: _this2.props.onErrorHandler,
            isExpanded: _this2.state.isExpanded
          });
        }
      })), !this.state.isShowingWarning && changelog.length > max && React.createElement("tbody", null, React.createElement("tr", null, React.createElement("td", {
        colSpan: "6",
        className: "expand"
      }, React.createElement("a", {
        onClick: this.handleToggleShowAll.bind(this)
      }, this.state.isShowAll ? "Hide" : "Show", " all ", changelog.length, " changes from changelog"), "\xA0", React.createElement("a", {
        onClick: this.handleToggleExpand.bind(this)
      }, "expanded"))))))));
    }
  }]);

  return ChangeLog;
}(React.Component);

var ChangeLogItem =
/*#__PURE__*/
function (_React$Component2) {
  _inherits(ChangeLogItem, _React$Component2);

  function ChangeLogItem(props) {
    var _this3;

    _classCallCheck(this, ChangeLogItem);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(ChangeLogItem).call(this, props));
    _this3.state = {
      isShowingWarning: false,
      isExpanded: false,
      undo_reason: ""
    };
    return _this3;
  }

  _createClass(ChangeLogItem, [{
    key: "clearForm",
    value: function clearForm() {
      var el = document.getElementById("changelog-action-" + this.props.item.txid).querySelector(".undo-money-button");

      if (el) {
        var parentNode = el.parentNode;
        parentNode.removeChild(el);
        var newEl = document.createElement('div');
        newEl.className = "undo-money-button";
        parentNode.appendChild(newEl);
      }
    }
  }, {
    key: "handleClickUndo",
    value: function handleClickUndo(e) {
      e.preventDefault();
      this.setState({
        "isShowingWarning": true
      });
    }
  }, {
    key: "handleUndoSubmit",
    value: function handleUndoSubmit(e) {
      var _this4 = this;

      e.preventDefault();
      var object = findObjectByTX(this.props.item.txid, this.props.txpool);

      if (!object) {
        alert("Error while finding undo object, please try again");
        return;
      }

      var action_id = findRootActionID(object, this.props.txpool);

      if (!action_id) {
        alert("Error while finding undo object action_id, please try again");
      }

      var OP_RETURN = [OPENDIR_PROTOCOL, "undo", action_id, this.props.item.txid];

      if (this.state.undo_reason) {
        OP_RETURN.push(this.state.undo_reason);
      } else {
        if (!confirm("Are you sure you want to continue? You didn't specify an undo reason.\n\nProviding a reason helps everyone understand your thinking behind this change, and can prevent it from being reverted in the future.")) {
          return;
        }
      }

      console.log(OP_RETURN);
      var el = document.getElementById("changelog-action-" + this.props.item.txid).querySelector(".undo-money-button");
      databutton.build({
        data: OP_RETURN,
        button: {
          $el: el,
          onPayment: function onPayment(msg) {
            setTimeout(function () {
              _this4.clearForm();

              _this4.setState({
                "isShowingWarning": false,
                "isExpanded": false,
                "undo_reason": ""
              });

              _this4.props.onSuccessHandler("Successfully reversed transaction, it will appear automatically—please refresh the page if it doesn't.");
            }, 3000);
          }
        }
      });
    }
  }, {
    key: "handleToggleExpand",
    value: function handleToggleExpand(e) {
      this.setState({
        "isExpanded": !this.state.isExpanded,
        "isShowingWarning": false
      });
    }
  }, {
    key: "handleChangeUndoReason",
    value: function handleChangeUndoReason(e) {
      this.setState({
        "undo_reason": e.target.value
      });
    }
  }, {
    key: "render",
    value: function render() {
      var timestamp = new Date().getTime();
      var amount = satoshisToDollars(this.props.item.satoshis, BSV_PRICE);
      var sats = this.props.item.satoshis > 0 ? this.props.item.satoshis + " sats" : "";
      var action;

      if (this.props.item.type == "admin") {
        action = this.props.item.type + "." + this.props.item.action;
      } else {
        action = this.props.item.data.s2;
      }

      var isUndoable = true;

      if (this.props.item.type == "admin") {
        isUndoable = false;
      } else if (this.props.item.type == "fork") {
        isUndoable = false;
      }

      return React.createElement(React.Fragment, null, React.createElement("tr", null, React.createElement("td", {
        className: "height"
      }, React.createElement("a", {
        onClick: this.handleToggleExpand.bind(this),
        className: "arrow"
      }, this.props.isExpanded || this.state.isExpanded ? React.createElement("i", {
        className: "fas fa-caret-down"
      }) : React.createElement("i", {
        className: "fas fa-caret-right"
      })), this.props.item.height ? React.createElement("span", {
        className: "block"
      }, "#", this.props.item.height) : React.createElement("span", {
        className: "pending"
      }, "pending")), React.createElement("td", {
        className: "action"
      }, action), React.createElement("td", {
        className: "time"
      }, timeDifference(timestamp, this.props.item.time * 1000)), React.createElement("td", {
        className: "amount",
        title: sats
      }, amount), React.createElement("td", {
        className: "description"
      }, this.props.item.description), React.createElement("td", {
        className: "address"
      }, this.props.item.address)), (this.props.isExpanded || this.state.isExpanded) && React.createElement("tr", null, React.createElement("td", {
        className: "data",
        colSpan: "6"
      }, React.createElement("pre", null, React.createElement("code", null, JSON.stringify(this.props.item.data, null, 4))))), (this.props.isExpanded || this.state.isExpanded) && React.createElement("tr", null, React.createElement("td", {
        className: "undo",
        colSpan: "6",
        id: "changelog-action-" + this.props.item.txid
      }, React.createElement("a", {
        target: "_blank",
        href: "https://whatsonchain.com/tx/" + this.props.item.txid
      }, this.props.item.txid), "\xA0", isUndoable && React.createElement("a", {
        onClick: this.handleClickUndo.bind(this)
      }, "undo"), this.state.isShowingWarning && React.createElement("div", {
        className: "notice"
      }, React.createElement("span", {
        className: "warning"
      }, "You are undoing this change, are you sure you want to do this?"), React.createElement("div", {
        className: "explain"
      }, React.createElement("p", null, "If you undo this change, you'll be permanently undoing it in this directory for everyone else. Please only do this if you think it's in the best interest of the directory. Your Bitcoin key is forever tied to this transaction, so it will always be traced to you."), React.createElement("p", null, React.createElement("strong", null, "Why are you undoing this change?")), React.createElement("form", {
        onSubmit: this.handleUndoSubmit.bind(this)
      }, React.createElement("input", {
        type: "text",
        placeholder: "reason for undo",
        value: this.state.undo_reason,
        onChange: this.handleChangeUndoReason.bind(this)
      }), " ", React.createElement("input", {
        type: "submit",
        className: "button button-outline",
        value: "undo"
      })), React.createElement("div", {
        className: "undo-money-button"
      }), " ")))));
    }
  }]);

  return ChangeLogItem;
}(React.Component);
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var OpenDirectoryApp =
/*#__PURE__*/
function (_React$Component) {
  _inherits(OpenDirectoryApp, _React$Component);

  function OpenDirectoryApp(props) {
    var _this;

    _classCallCheck(this, OpenDirectoryApp);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(OpenDirectoryApp).call(this, props));
    _this.state = {
      isLoading: true,
      isError: false,
      isExpandingAddCategoryForm: false,
      isExpandingAddEntryForm: false,
      isForking: false,
      location: [""],
      messages: [],
      changelog: [],
      // response from network
      txpool: [],
      // semi-processed results from network
      items: [],
      // current items
      admin_actions: [],
      taches: [],
      // attach and detaches
      category: {
        "txid": get_root_category_txid(),
        "needsupdate": true
      },
      link: null,
      title: SETTINGS.title,
      intro_markdown: SETTINGS.intro_markdown,
      faq_markdown: SETTINGS.faq_markdown,
      theme: SETTINGS.theme,
      template_txid: SETTINGS.template_txid
    };
    _this.tag = "beta";
    _this.NETWORK_DELAY = 0;
    _this._isMounted = false;
    _this.addSuccessMessage = _this.addSuccessMessage.bind(_assertThisInitialized(_this));
    _this.addErrorMessage = _this.addErrorMessage.bind(_assertThisInitialized(_this));
    _this.didUpdateLocation = _this.didUpdateLocation.bind(_assertThisInitialized(_this));
    _this.changeURL = _this.changeURL.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(OpenDirectoryApp, [{
    key: "componentDidCatch",
    value: function componentDidCatch(error, info) {
      console.log("ERROR", error, info);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this._isMounted = true;
      this.didUpdateLocation();
      this.performAdminActionsFetch();
      this.detectTemplateIDFromAddress();
      this.networkAPIFetch();
      updateBitcoinSVPrice();
      window.addEventListener('popstate', this.didUpdateLocation.bind(this), false);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._isMounted = false;
    }
  }, {
    key: "addMessage",
    value: function addMessage(msg, type) {
      var _this2 = this;

      var cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5000;
      var key = new Date().getTime();
      var messages = this.state.messages.concat([{
        "type": type,
        "message": msg,
        "key": key
      }]);
      this.setState({
        "messages": messages
      }, function () {
        setTimeout(function () {
          _this2.hideMessage(key);
        }, timeout);

        if (cb) {
          cb();
        }
      });
    }
  }, {
    key: "addSuccessMessage",
    value: function addSuccessMessage(msg) {
      var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5000;
      this.addMessage(msg, "success", cb, timeout);
    }
  }, {
    key: "addErrorMessage",
    value: function addErrorMessage(msg) {
      var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5000;
      this.addMessage(msg, "error", cb, timeout);
    }
  }, {
    key: "hideMessage",
    value: function hideMessage(key) {
      var messages = this.state.messages.map(function (m) {
        if (m.key == key) {
          m.deleted = true;
        }

        return m;
      });
      this.setState({
        "messages": messages
      });
    }
  }, {
    key: "detectTemplateIDFromAddress",
    value: function detectTemplateIDFromAddress() {
      // If template_txid is not set, attempt to detect it from our current address
      if (!this.state.template_txid) {
        var url = document.location.href;
        var template_txid;

        if (url.indexOf("bit://") !== -1) {
          var parts = url.split("/");

          if (parts.length !== 4) {
            console.log("Unable to detect template ID from address, unknown parts in url");
            return;
          }

          if (parts[2] !== B_MEDIA_PROTOCOL && parts[2] !== BCAT_MEDIA_PROTOCOL) {
            console.log("Unable to detect template ID from address, unknown parts in url");
            return;
          }

          template_txid = parts[3];
        } else if (url.indexOf("b://") !== -1 || url.indexOf("bcat://") !== -1) {
          var _parts = url.split("/");

          template_txid = _parts[2];
        }

        if (template_txid) {
          if (template_txid.length !== 64) {
            console.log("Unable to detect valid template ID from address, invalid tx");
            return;
          }

          console.log("Successfully detected template_txid", template_txid, "from address", url);
          this.setState({
            "template_txid": template_txid
          });
        }
      }
    }
  }, {
    key: "handleCloseFork",
    value: function handleCloseFork() {
      this.setState({
        "isForking": false
      });
    }
  }, {
    key: "handleChangeTitle",
    value: function handleChangeTitle(e) {
      this.setState({
        "title": e.target.value
      });
    }
  }, {
    key: "didChangeFAQHandler",
    value: function didChangeFAQHandler(e) {
      console.log("FAQ", e.target.value);
      this.setState({
        "faq_markdown": e.target.value
      });
    }
  }, {
    key: "handleToggleFork",
    value: function handleToggleFork() {
      this.setState({
        "isForking": !this.state.isForking
      });
    }
  }, {
    key: "didChangeIntroHandler",
    value: function didChangeIntroHandler(e) {
      this.setState({
        "intro_markdown": e.target.value
      });
    }
  }, {
    key: "handleChangeTheme",
    value: function handleChangeTheme(theme) {
      this.setState({
        "theme": theme
      });
    }
  }, {
    key: "buildChangeLog",
    value: function buildChangeLog(txid) {
      var _this3 = this;

      var admin_changelog = processAdminResults(this.state.admin_actions).filter(function (r) {
        // show homepage redirects
        if (!txid && r.type == "uri") {
          return true;
        } // if action_id references this txid


        if (r.action_id == txid) {
          return true;
        } // check if action_id references


        if (r.action_id) {
          var obj = findObjectByTX(r.action_id, _this3.state.items);

          if (obj && obj.type == "category" && (!obj.category_id || obj.txid == r.action_id)) {
            return true;
          }
        }

        return false;
      });
      var changelog = buildRawSliceRepresentationFromCache(this.state.category.txid, this.state.changelog, this.state.items);

      if (!changelog) {
        changelog = [];
      }

      changelog = changelog.filter(function (r) {
        return OPENDIR_ACTIONS.indexOf(r.data.s2) !== -1;
      });
      var combined = changelog.concat(admin_changelog);
      var sorted = combined.sort(function (a, b) {
        return (a.height === null) - (b.height === null) || +(a.height > b.height) || -(a.height < b.height);
      });
      return sorted;
    }
  }, {
    key: "handleChangeCategory",
    value: function handleChangeCategory(txid) {
      SETTINGS.category = txid;
      this.didUpdateLocation();
    }
  }, {
    key: "getForks",
    value: function getForks() {
      var txid = this.state.category.txid; // TODO: Need to update forks too

      var forks = this.state.txpool.filter(function (i) {
        return i.type == "fork";
      });
      var sorted = forks.sort(function (a, b) {
        if (a.satoshis < b.satoshis) {
          return 1;
        }

        if (a.satoshis > b.satoshis) {
          return -1;
        }

        return 0;
      });
      return sorted;
    }
  }, {
    key: "handleExpandAddCategoryForm",
    value: function handleExpandAddCategoryForm() {
      this.setState({
        "isExpandingAddCategoryForm": true
      });
    }
  }, {
    key: "handleExpandAddEntryForm",
    value: function handleExpandAddEntryForm() {
      this.setState({
        "isExpandingAddEntryForm": true
      });
    }
  }, {
    key: "changeURL",
    value: function changeURL(path) {
      history.pushState(null, null, path);
      window.scrollTo(0, 0);
      this.didUpdateLocation();
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var path = this.getLocation();
      var items = buildItemSliceRepresentationFromCache(this.state.category.txid, this.state.items);
      var body, loading, error;
      var shouldShowAddNewCategoryForm = false,
          shouldShowAddNewEntryForm = false;
      var changelog;
      var forks;

      if (path == "/faq") {
        body = React.createElement("div", {
          className: "faq"
        }, React.createElement(ReactMarkdown, {
          source: this.state.faq_markdown
        }));
      } else if (path == "/stats") {
        // TODO: Refactor into StatsPage
        // TODO: This looks like duplicate
        if (items.length == 0) {
          body = React.createElement("div", {
            className: "stats"
          }, React.createElement("h2", null, "Statistics"), React.createElement("p", null, "Please visit the homepage first, let it load then return. This will be fixed soon!"));
        } else {
          var _changelog = this.buildChangeLog(null);

          var category = React.createElement("a", {
            onClick: function onClick() {
              _this4.changeURL("/");
            }
          }, "Open Directory");

          if (this.state.category.txid) {
            category = React.createElement("a", {
              onClick: function onClick() {
                _this4.changeURL("/category/" + _this4.state.category.txid);
              }
            }, this.state.category.name);
          }

          var numCategories = 0;
          var numEntries = 0;
          var numSatoshis = 0;
          var numVotes = 0;
          var biggestTip = 0;
          var biggestTipAddress = null;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _changelog[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var log = _step.value;

              if (log.data.s2.indexOf("entry") == 0) {
                numEntries += 1;

                if (log.satoshis > 0) {
                  numSatoshis += log.satoshis;

                  if (log.satoshis > biggestTip) {
                    biggestTip = log.satoshis;
                    biggestTipAddress = log.address;
                  }
                }
              } else if (log.data.s2.indexOf("category") == 0) {
                numCategories += 1;

                if (log.satoshis > 0) {
                  numSatoshis += log.satoshis;

                  if (log.satoshis > biggestTip) {
                    biggestTip = log.satoshis;
                    biggestTipAddress = log.address;
                  }
                }
              } else if (log.data.s2 == "vote") {
                numVotes += 1;

                if (log.satoshis > 0) {
                  numSatoshis += log.satoshis;

                  if (log.satoshis > biggestTip) {
                    biggestTip = log.satoshis;
                    biggestTipAddress = log.address;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          body = React.createElement("div", {
            className: "stats"
          }, React.createElement("h2", null, "Statistics for ", category), React.createElement("ul", null, React.createElement("li", null, "Actions: ", _changelog.length), React.createElement("li", null, "Categories: ", numCategories), React.createElement("li", null, "Links: ", numEntries), React.createElement("li", null, "Upvotes: ", numVotes), biggestTip && React.createElement("li", null, "Biggest tip: ", satoshisToDollars(biggestTip), " by ", biggestTipAddress), React.createElement("li", null, numberFormat(numSatoshis / 100000000), " BSV / ", satoshisToDollars(numSatoshis, BSV_PRICE), " spent"), React.createElement("li", null, "BSV Price: $", BSV_PRICE)));
        }
      } else if (path == "/search") {
        body = React.createElement(SearchPage, {
          title: this.state.title,
          items: items,
          category: this.state.category,
          changeURL: this.changeURL
        });
      } else if (path == "/add-directory") {
        body = React.createElement(AddDirectoryPage, {
          category: this.state.category,
          onSuccessHandler: this.addSuccessMessage,
          onErrorHandler: this.addErrorMessage
        });
      } else if (this.state.link) {
        // TODO: Move all this to an LinkPage
        var back;

        if (this.state.category) {
          var root_category_txid = get_root_category_txid();

          if (root_category_txid == null || this.props.category.txid !== root_category_txid) {
            var parent_url = "/category/" + this.state.category.txid;

            if (this.state.category.txid == root_category_txid) {
              parent_url = "/";
            }

            back = React.createElement("div", {
              className: "back"
            }, React.createElement("a", {
              onClick: function onClick() {
                _this4.props.changeURL(parent_url);
              }
            }, React.createElement("i", {
              className: "fas fa-long-arrow-alt-left"
            }), " ", parent.name), React.createElement("hr", null));
          }
        }

        body = React.createElement("div", {
          className: "link-meta",
          id: this.state.link.txid
        }, back, React.createElement("div", {
          className: "upvoteContainer"
        }, React.createElement("div", {
          className: "upvote"
        }, React.createElement("a", null, React.createElement("i", {
          className: "fas fa-chevron-up"
        })), " ", React.createElement("span", {
          className: "number satoshis",
          title: this.state.link.satoshis + " sats"
        }, this.state.link.satoshis), React.createElement("span", {
          className: "number votes",
          title: this.state.link.hottness + " hottness"
        }, pluralize(this.state.link.votes, "vote", "votes"))), React.createElement("div", null, React.createElement("h1", null, this.state.link.name), React.createElement("div", {
          className: "markdown"
        }, React.createElement(ReactMarkdown, {
          source: this.state.link.description
        })), React.createElement("div", {
          className: "clearfix"
        }))));
      } else {
        if (!this.state.isLoading && !this.state.isError) {
          shouldShowAddNewCategoryForm = true;

          if (this.state.category.txid) {
            shouldShowAddNewEntryForm = true;
          }
        }

        changelog = this.buildChangeLog(this.state.category.txid);
        forks = this.getForks();

        if (!this.state.isError) {
          var filtered_items = this.filterOutDetaches(items);
          var list, list_class_name;

          if (this.state.category.txid) {
            list = React.createElement(SubcategoryList, {
              items: filtered_items,
              category: this.state.category,
              isError: this.state.isError,
              isLoading: this.state.isLoading,
              onSuccessHandler: this.addSuccessMessage,
              onErrorHandler: this.addErrorMessage,
              changeURL: this.changeURL
            });
            list_class_name = "subcategories";
          } else {
            list = React.createElement("div", null, React.createElement(HomepageEntries, {
              items: filtered_items,
              isError: this.state.isError,
              isLoading: this.state.isLoading,
              onSuccessHandler: this.addSuccessMessage,
              onErrorHandler: this.addErrorMessage,
              limit: 15,
              show_category: true,
              changeURL: this.changeURL
            }), React.createElement("div", {
              className: "clearfix"
            }), React.createElement(HomepageList, {
              items: filtered_items,
              category: this.state.category,
              isError: this.state.isError,
              isLoading: this.state.isLoading,
              onSuccessHandler: this.addSuccessMessage,
              onErrorHandler: this.addErrorMessage,
              changeURL: this.changeURL
            }));
            list_class_name = "homepage";
          }

          body = React.createElement("div", {
            className: list_class_name + " list-wrapper"
          }, list);
        }

        loading = React.createElement("div", {
          className: "loading"
        }, React.createElement("div", {
          className: "spinner"
        }, React.createElement("div", {
          className: "bounce1"
        }), React.createElement("div", {
          className: "bounce2"
        }), React.createElement("div", {
          className: "bounce3"
        })), React.createElement("p", null, "Loading ", this.state.title, "..."));
        error = React.createElement("div", null, React.createElement("h2", null, "Error"), React.createElement("p", null, React.createElement("strong", null, "Sorry, there was an error while loading open directory information. Please refresh to try again or contact ", React.createElement("a", {
          href: "https://twitter.com/synfonaut"
        }, "@synfonaut"))), React.createElement("br", null), React.createElement("p", null, React.createElement("button", {
          onClick: function onClick() {
            location.reload();
          },
          className: "button button-outline"
        }, "Refresh This Page")));
      }

      var intro;

      if (this.state.intro_markdown) {
        intro = React.createElement("div", {
          className: "intro"
        }, React.createElement(ReactMarkdown, {
          source: this.state.intro_markdown
        }));
      } else {
        intro = intro = React.createElement("div", {
          className: "intro"
        }, React.createElement("h1", null, React.createElement("i", {
          className: "fas fa-sitemap"
        }), " Open Directory ", React.createElement("span", {
          className: "beta"
        }, this.tag)), React.createElement("div", {
          className: "learn-more"
        }, React.createElement("p", null, "Open Directory is an open-source way for anyone to earn money by organizing links on the Bitcoin (SV) blockchain. Find the best content and earn money by submitting great links! ", !this.state.isExpandingLearnMore && React.createElement("span", null, React.createElement("a", {
          href: "/faq"
        }, "Learn more"), "..."))), React.createElement(SearchPage, {
          title: this.state.title,
          items: items,
          category: this.state.category,
          embed: true,
          changeURL: this.changeURL
        }));
      }

      return React.createElement("div", {
        className: this.state.theme + " wrapper"
      }, this.state.isForking && React.createElement(Fork, {
        onCloseFork: this.handleCloseFork.bind(this),
        onErrorHandler: this.addErrorMessage,
        introMarkdown: this.state.intro_markdown,
        onIntroChange: this.didChangeIntroHandler.bind(this),
        theme: this.state.theme,
        onChangeTheme: this.handleChangeTheme.bind(this),
        title: this.state.title,
        onChangeTitle: this.handleChangeTitle.bind(this),
        faqMarkdown: this.state.faq_markdown,
        onFAQChange: this.didChangeFAQHandler.bind(this),
        items: items,
        onChangeCategory: this.handleChangeCategory.bind(this),
        template_txid: this.state.template_txid
      }), React.createElement("nav", {
        className: "navigation"
      }, React.createElement("section", {
        className: "container"
      }, React.createElement("div", {
        className: "navigation-title"
      }, React.createElement("a", {
        onClick: function onClick() {
          _this4.changeURL("/");
        }
      }, React.createElement("i", {
        className: "fas fa-sitemap"
      }), this.state.title), React.createElement("span", {
        className: "beta"
      }, this.tag)), React.createElement("div", {
        className: this.state.networkActive ? "spinner white active" : "spinner white"
      }, React.createElement("div", {
        className: "bounce1"
      }), React.createElement("div", {
        className: "bounce2"
      }), React.createElement("div", {
        className: "bounce3"
      })), React.createElement("ul", {
        className: "navigation-list float-right"
      }, React.createElement("li", {
        className: "navigation-item"
      }, React.createElement("a", {
        className: "navigation-link nav-search",
        onClick: function onClick() {
          _this4.changeURL("/search");
        }
      }, React.createElement("i", {
        className: "fas fa-search"
      }, " "), "Search"), React.createElement("a", {
        className: "navigation-link nav-stats",
        onClick: function onClick() {
          _this4.changeURL("/stats");
        }
      }, "Stats"), React.createElement("a", {
        className: "navigation-link nav-faq",
        onClick: function onClick() {
          _this4.changeURL("/faq");
        }
      }, "FAQ"), React.createElement("a", {
        className: "navigation-link nav-fork",
        onClick: this.handleToggleFork.bind(this)
      }, "Fork"))))), React.createElement("div", {
        className: "container"
      }, React.createElement("div", {
        className: "open-directory"
      }, React.createElement(PoseGroup, null, this.state.messages.length > 0 && React.createElement(MessageGroup, {
        key: "message_group",
        className: "messages"
      }, this.state.messages.map(function (m) {
        var classes = ["message", m.type];

        if (m.deleted) {
          classes.push("deleted");
        }

        return React.createElement(Message, {
          key: m.key,
          className: classes.join(" ")
        }, m.message);
      }))), path == "/" && intro, body, this.state.isLoading && items.length == 0 && loading, this.state.isError && error, React.createElement("hr", null), React.createElement("div", {
        className: "row"
      }, shouldShowAddNewEntryForm ? React.createElement("div", {
        className: "column"
      }, !this.state.isExpandingAddEntryForm && React.createElement("div", {
        className: "add-entry-callout"
      }, React.createElement("a", {
        onClick: this.handleExpandAddEntryForm.bind(this)
      }, React.createElement("i", {
        "class": "fas fa-link"
      }), " Submit a new link"), React.createElement("p", null, "Earn ", React.createElement("i", {
        className: "fab fa-bitcoin"
      }), " Bitcoin (SV) by submitting valuable content\u2014when it gets upvoted you'll receive a portion of the tip!")), this.state.isExpandingAddEntryForm && React.createElement(AddEntryForm, {
        category: this.state.category,
        onSuccessHandler: this.addSuccessMessage,
        onErrorHandler: this.addErrorMessage
      })) : null, shouldShowAddNewCategoryForm && !shouldShowAddNewEntryForm ? React.createElement("div", {
        className: "row"
      }, React.createElement("div", {
        className: "column"
      }, !this.state.isExpandingAddCategoryForm && React.createElement("div", {
        className: "add-directory-callout"
      }, React.createElement("a", {
        onClick: this.handleExpandAddCategoryForm.bind(this)
      }, React.createElement("i", {
        "class": "fas fa-folder"
      }), " Create a new directory"), React.createElement("p", null, "Earn ", React.createElement("i", {
        className: "fab fa-bitcoin"
      }), " Bitcoin (SV) by creating a new directory\u2014when someone submits content and it gets upvoted you'll receive a portion of the tip! ")), this.state.isExpandingAddCategoryForm && React.createElement(AddCategoryForm, {
        category: this.state.category,
        onSuccessHandler: this.addSuccessMessage,
        onErrorHandler: this.addErrorMessage
      })), React.createElement("div", {
        className: "column"
      })) : null, shouldShowAddNewCategoryForm && shouldShowAddNewEntryForm ? React.createElement("div", {
        className: "column"
      }, !this.state.isExpandingAddCategoryForm && React.createElement("div", {
        className: "add-category-callout"
      }, React.createElement("a", {
        onClick: this.handleExpandAddCategoryForm.bind(this)
      }, React.createElement("i", {
        "class": "fas fa-folder"
      }), " Create a new subcategory "), React.createElement("p", null, "Earn ", React.createElement("i", {
        className: "fab fa-bitcoin"
      }), " Bitcoin (SV) by creating a new subcategory\u2014when someone submits content and it gets upvoted you'll receive a portion of the tip! ")), this.state.isExpandingAddCategoryForm && React.createElement(AddCategoryForm, {
        category: this.state.category,
        onSuccessHandler: this.addSuccessMessage,
        onErrorHandler: this.addErrorMessage
      })) : null), (shouldShowAddNewEntryForm || shouldShowAddNewCategoryForm) && React.createElement("hr", null), !this.state.isLoading && React.createElement(ForkLog, {
        forks: forks,
        onSuccessHandler: this.addSuccessMessage,
        onErrorHandler: this.addErrorMessage
      }), !this.state.isLoading && React.createElement(ChangeLog, {
        changelog: changelog,
        txpool: this.state.txpool,
        category: this.state.category,
        onSuccessHandler: this.addSuccessMessage,
        onErrorHandler: this.addErrorMessage
      }))));
    }
  }, {
    key: "performAdminActionsFetch",
    value: function performAdminActionsFetch() {
      var _this5 = this;

      getCachedAdminActions().then(function (actions) {
        _this5.setState({
          "admin_actions": actions
        });

        _this5.performAdminUpdateCheck();
      })["catch"](function (e) {
        console.log("Error while checking for admin actions", e);

        _this5.addErrorMessage("Error while checking for admin actions");
      });
    }
  }, {
    key: "performAdminUpdateCheck",
    value: function performAdminUpdateCheck() {
      var _this6 = this;

      // TODO: Figure out best way to handle this
      // General thought was if deployed to http then don't redirect, but that doesn't work for bico.media and others
      // Need a good way to know when should we redirect?
      if (document.location.hostname == "dir.sv" || document.location.hostname == "alpha.dir.sv") {
        console.log("Skipping app update check since running at known http/https site");
        return;
      }

      var currentURL = [location.protocol, '//', location.host, location.pathname].join('');
      getLatestUpdate().then(function (update) {
        if (currentURL != update.uri) {
          console.log("Current location doesn't match latest update URI...new version available", currentURL, update.uri);
          var redirect_url = React.createElement("a", {
            href: update.uri
          }, "new version");

          _this6.addSuccessMessage(React.createElement("div", null, _this6.state.title, " has a ", redirect_url, " available, check it out!"), null, 10000);
        } else {
          console.log("Using most recent version of app");
        }
      });
    }
  }, {
    key: "getOldLocation",
    value: function getOldLocation() {
      return window.location.hash.replace(/^#\/?|\/$/g, '').split('/');
    }
  }, {
    key: "filterOutDetaches",
    value: function filterOutDetaches(results) {
      var taches = processAdminResults(this.state.admin_actions).filter(function (a) {
        return a.action == "attach" || a.action == "detach";
      });

      if (results.length > 0 && taches.length > 0) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = taches[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var tach = _step2.value;
            var result = findObjectByTX(tach.action_id, results);

            if (result) {
              if (tach.action == "detach") {
                result.detached = true;
              } else if (tach.action == "attach") {
                delete result["detached"];
              }
            } else {// console.log("unable to find result for tach", tach);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }

      return results.filter(function (r) {
        return !r.detached;
      });
    }
  }, {
    key: "getLocation",
    value: function getLocation() {
      var path = window.location.pathname;

      if (path == "/") {
        var hash = this.getOldLocation();

        if (hash.length == 1 && hash[0] !== "") {
          path = "/category/" + hash[0]; // support the old hash url system
        }
      }

      return path;
    }
  }, {
    key: "didUpdateLocation",
    value: function didUpdateLocation() {
      var _this7 = this;

      var path = this.getLocation();
      console.log("location updated", path);
      var category = this.state.category;
      var link = this.state.link;
      var items = [];
      var title = this.state.title;
      var needsupdate = false;

      if (path == "/faq") {
        title = "FAQ " + this.state.title;
      } else if (path == "/stats") {
        title = "Statistics for " + this.state.title;
        items = buildItemSliceRepresentationFromCache(category.txid, this.state.items);
      } else if (path == "/search") {
        title = "Search " + this.state.title;
        needsupdate = true;
      } else if (path == "/add-directory") {
        title = "Add directory to " + this.state.title;
        needsupdate = true;
      } else {
        var category_id;

        if (path == "/") {
          category_id = get_root_category_txid();
        } else {
          var parts = path.split("/");

          if (parts.length > 0) {
            if (parts[1] == "category") {
              category_id = parts[2];
            } else {
              console.log("CANT FIND CATEGORY", parts);
              this.setState({
                "isError": true,
                "isLoading": false
              });
              return;
            }
          } else {
            console.log("CANT FIND CATEGORY", path);
            this.setState({
              "isError": true,
              "isLoading": false
            });
            return;
          }
        }

        var cached = buildItemSliceRepresentationFromCache(category_id, this.state.items);
        category = {
          "txid": category_id,
          "needsdata": true
        };
        needsupdate = true;

        if (cached && cached.length > 0) {
          items = cached;
          var cachedCategory = findObjectByTX(category_id, this.state.items);

          if (cachedCategory) {
            cachedCategory.needsdata = true; // don't know for sure the server hasn't updated since we last cached

            title = cachedCategory.name + " — " + this.state.title;
            category = cachedCategory;
          }
        }
      }

      document.title = title;

      if (location !== this.state.location) {
        window.scrollTo(0, 0);
      }

      this.setState({
        "location": location,
        "category": category,
        "link": link,
        "items": items,
        "isExpandingAddCategoryForm": false,
        "isExpandingAddEntryForm": false
      }, function () {
        if (needsupdate) {
          _this7.networkAPIFetch();
        }
      });
    }
  }, {
    key: "networkAPIFetch",
    value: function networkAPIFetch() {
      var _this8 = this;

      console.log("network fetching");
      var state = {
        networkActive: true
      };

      if (this.state.items.length == 0) {
        state.isLoading = true;
      }

      this.setState(state);
      setTimeout(function () {
        fetch_from_network().then(function (rows) {
          if (_this8.state.changelog.length > 0) {
            rows = _this8.state.changelog;
          }

          var txpool = processOpenDirectoryTransactions(rows);
          var results = processResults(rows, txpool);

          var success = _this8.checkForUpdatedActiveCategory(results);

          _this8.setState({
            "networkActive": false,
            "isLoading": false,
            "isError": !success,
            "txpool": txpool,
            "items": results,
            "changelog": rows
          });

          _this8.setupNetworkSocket();
        })["catch"](function (e) {
          console.log("error", e);

          _this8.setState({
            "isLoading": false,
            "networkActive": false,
            "isError": true
          });
        });
      }, this.NETWORK_DELAY);
    }
  }, {
    key: "checkForUpdatedActiveCategory",
    value: function checkForUpdatedActiveCategory(results) {
      if (this.state.category && this.state.category.txid && this.state.category.needsdata) {
        // hacky...better way?
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = results[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var result = _step3.value;

            if (result.type == "category" && result.txid == this.state.category.txid) {
              this.setState({
                category: result
              });
              document.title = result.name + " — " + this.state.title;
              return true;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        console.log("error during checkForUpdatedActiveCategory");
        return false;
      }

      return true;
    }
  }, {
    key: "setupNetworkSocket",
    value: function setupNetworkSocket() {
      var _this9 = this;

      if (this.socket) {
        return;
      }

      console.log("setting up new network socket");
      var query = get_bitdb_query(this.state.category ? this.state.category.txid : get_root_category_txid());
      var encoded_query = toBase64(JSON.stringify(query));
      var api_url = SETTINGS["api_endpoint"].replace("{api_key}", SETTINGS.api_key).replace("{api_action}", "s");
      ;
      var url = api_url.replace("{query}", encoded_query);
      this.socket = new EventSource(url);

      this.socket.onmessage = function (e) {
        try {
          var resp = JSON.parse(e.data);

          if ((resp.type == "c" || resp.type == "u") && resp.data.length > 0) {
            var rows = [];

            for (var i = 0; i < resp.data.length; i++) {
              if (resp.data[i] && resp.data[i].data && resp.data[i].data.s1 == OPENDIR_PROTOCOL) {
                rows.push(resp.data[i]);
              }
            }

            if (rows.length > 0) {
              console.log("handled new message", resp);

              _this9.insertNewRowsFromNetwork(rows);
            }
          }
        } catch (e) {
          console.log("error handling network socket data", e.data); //throw e;
        }
      };

      this.socket.onerror = function (e) {
        console.log("socket error", e);

        if (_this9.socket) {
          _this9.socket.close();

          _this9.socket = null;
        }

        _this9.setupNetworkSocket();
      };
    }
  }, {
    key: "insertNewRowsFromNetwork",
    value: function insertNewRowsFromNetwork(socket_rows) {
      var _this10 = this;

      console.log("Inserting new rows from network", socket_rows.length);
      fetch_raw_txid_results(socket_rows).then(function (new_rows) {
        var rows = addNewRowsToExistingRows(new_rows, _this10.state.changelog);
        var txpool = processOpenDirectoryTransactions(rows);
        var results = processResults(rows, txpool);

        var success = _this10.checkForUpdatedActiveCategory(results);

        var category = _this10.state.category;

        if (category.txid) {
          category = findObjectByTX(_this10.state.category.txid, results);
        }

        _this10.setState({
          "isError": !success,
          "txpool": txpool,
          "items": results,
          "category": category,
          "changelog": rows
        });
      });
    }
  }]);

  return OpenDirectoryApp;
}(React.Component);

var MessageGroup = posed.div({
  enter: {
    applyAtStart: {
      display: "block"
    },
    opacity: 1,
    beforeChildren: true
  },
  exit: {
    applyAtEnd: {
      display: "none"
    },
    opacity: 0,
    beforeChildren: true
  }
});
var Message = posed.div({});
var application = React.createElement(OpenDirectoryApp, null);
ReactDOM.render(application, document.getElementById("app"));